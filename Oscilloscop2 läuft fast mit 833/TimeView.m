////  TimeView.m//  Oscilloscop2////  Created by Heinz-Jšrg on Sun Jun 1 2003.//  Copyright (c) 2003 Heinz-Jšrg SCHR…DER. All rights reserved.#import 	"ScientificView.h"#import 	"TimeView.h"#import 	"GraphAxis.h"#import 	"HorizontalGraphAxis.h"#import 	"VerticalGraphAxis.h"#import		"MyDocument.h"const double	Scale = 128.0;@implementation TimeView- (id)		initWithFrame:(NSRect)frame{		    lastFirstResponder = nil;    [super initWithFrame:frame];    [self windowFromX:0 ToX:6.3 AndFromY:-2 ToY:2];	triggerSelection = 0;	overPrint = 0;    running = NO;	state = 0;    xStart = 0.0;	xStop = 6.3;	samplingPeriod  = 0.1;	backgroundColor = [NSColor colorWithDeviceRed:0.1f green:0.7f blue:0.1f alpha:1.0];	[backgroundColor retain];	foregroundColor = [NSColor whiteColor];//[NSColor colorWithDeviceRed:1.0f green:1.0f blue:0.0f alpha:1.0];	gridColor	    = [NSColor greenColor];//[NSColor colorWithDeviceRed:0.0f green:1.0f blue:0.0f alpha:0.5];		//[self setTimerRunning:YES sender:self];    return self;}- (void)	zoomInFromPoint:(NSPoint)mouseLoc{    float                   xLeft, xRight;    NSPoint                 myLocation;        // reset transform matrix    myLocation.x = (mouseLoc.x-x_offset)/x_scale;    myLocation.y = (mouseLoc.y-y_offset)/y_scale;        xLeft = -(myLocation.x-windowRect.origin.x)/2;    xRight = (windowRect.origin.x-myLocation.x+windowRect.size.width)/2;        [self windowFromX:myLocation.x+xLeft ToX:myLocation.x+xRight AndFromY:windowRect.origin.y ToY:windowRect.origin.y+windowRect.size.height];    [self secondaryFromX:myLocation.x+xLeft ToX:myLocation.x+xRight];	    [self setNeedsDisplay: YES];}- (void)	zoomOutFromPoint:(NSPoint)mouseLoc{    float                   xLeft, xRight;    NSPoint                 myLocation;        myLocation.x = (mouseLoc.x-x_offset)/x_scale;    myLocation.y = (mouseLoc.y-y_offset)/y_scale;    xLeft = -(myLocation.x-windowRect.origin.x)*2;    xRight = (windowRect.origin.x-myLocation.x+windowRect.size.width)*2;        [self windowFromX:myLocation.x+xLeft ToX:myLocation.x+xRight AndFromY:windowRect.origin.y ToY:windowRect.origin.y+windowRect.size.height];    [self secondaryFromX:myLocation.x+xLeft ToX:myLocation.x+xRight];	    [self setNeedsDisplay: YES];}- (void)	mouseEntered:(NSEvent *)theEvent{    [[self window] setAcceptsMouseMovedEvents:YES];        lastFirstResponder = [[self window]firstResponder];    [[self window] makeFirstResponder:self];}- (void)	mouseExited:(NSEvent *)theEvent{    [[self window] setAcceptsMouseMovedEvents:NO];    if (lastFirstResponder) {        [[self window] makeFirstResponder:lastFirstResponder];        lastFirstResponder = nil;    }}- (void)	mouseMoved:(NSEvent *)theEvent{}- (void)	drawRect:(NSRect)rect{            	[backgroundColor set];	NSRectFill(rect);    if (!NSEqualRects(rubberbandRect, NSZeroRect)) {        [[NSColor knobColor] set];        NSFrameRect(rubberbandRect);    }	    [self choosePrimary];    if([self inLiveResize]) {        // do not recalculate        //glFlush();    } else {        //[[self openGLContext] flushBuffer];    }        overPrint = 0;            [self drawAnother:nil];	[self drawAxis];    [self choosePrimary];}- (void)    drawAnother:(id)timer{	double          x = 0;    double          value = 0;    static int		oneRowCount = 0;	//double			y1, y2;	unsigned		myLength;	double			myTrigger;	enum {waitForLow, waitForHigh, triggered};	enum {autoTrigger, normalTrigger, singleTrigger};	enum {edgeHighLow, edgeLowHigh, smart};	//static int		triggerFormat = edgeLowHigh;	//static int		triggerMode = autoTrigger;	static int		triggerState = waitForLow;	BOOL			triggerOk = false;	char			*myBuffer = [myDocument buffer];                    	if ([[self window] isVisible] && myBuffer) {               		myLength  = [myDocument length];		myTrigger = [triggerValue intValue]/Scale;		// Lock focus on ourselves.  We need to do this because we're drawing outside of the context of NSView's drawRect: method.  This is relatively unusual behaviour for a view. 		[self lockFocus];		[self lineWidth:0.2];		[self penup];				// draw the values filtered		switch (triggerState) {			case waitForLow:				for (x = 0; x < xStop/samplingPeriod; x++) {					value = myBuffer[oneRowCount % myLength]/Scale;					if (value < myTrigger) {						triggerState = waitForHigh;						goto WaitForHigh;						break;					}					oneRowCount++;				}				goto Triggered;				break;			case waitForHigh:	WaitForHigh:				triggerState = waitForLow;				for (x = 0; x < xStop/samplingPeriod/2; x++) {					oneRowCount++;					value = myBuffer[oneRowCount % myLength]/Scale;					if (value > myTrigger) {						triggerState = triggered;						triggerOk = true;						goto Triggered;						break;					}				}				goto Triggered;				break;			case triggered:	Triggered:				myDensity = [Density doubleValue];				if (state > [Remanenz intValue]) {					myWhite = [White doubleValue];					myAlpha = [Alpha doubleValue];					myCompositeMode = [CompositeMode intValue];									[self drawAxis];					[[NSColor colorWithDeviceRed:myWhite green:myWhite blue:myWhite alpha:myAlpha] set];					NSRectFillUsingOperation([self bounds], myCompositeMode);					state = 0;				} else {					state++;				}				[[NSColor colorWithDeviceRed:1.0f green:1.0f blue:1.0f alpha:myDensity] set];				[self penup];				oneRowCount += myLength-1;				if (triggerOk) {					xStart = samplingPeriod*(myTrigger*Scale-myBuffer[(oneRowCount) % myLength])/(myBuffer[(oneRowCount+0) % myLength]-myBuffer[(oneRowCount+1) % myLength]);				} else {					x = 0;				}				for (x = xStart; x < xStop; x+=samplingPeriod) {					value = myBuffer[oneRowCount % myLength]/Scale;					[self plotto:x					:value];					//[self plotto:x+samplingPeriod   :value];					oneRowCount++;				}							overPrint ++;				[test setIntValue:overPrint];				triggerState = waitForLow;				break;		}				[self unlockFocus];		[[self window] flushWindow];	}}- (void)		drawAxis{    float			gridLineWidth = 0.05;	double			myTrigger = [triggerValue intValue]/Scale;    [horizontalAxis	setGridRect:&windowRect];    [verticalAxis	setGridRect:&windowRect];                //[[NSColor greenColor] set];	[[NSColor colorWithDeviceRed:0.0f green:1.0f blue:0.0f alpha:1.0] set];    // draw x and y axis for primary plot    [horizontalAxis	linTics:windowRect.origin.y separation:0.0 ticPercent:200 andMajorEvery:10 lineWidth:gridLineWidth];     [verticalAxis	linTics:windowRect.origin.x separation:0.0 ticPercent:200 andMajorEvery:10 lineWidth:gridLineWidth];                                [self lineWidth:1.2];    [[NSColor redColor] set];    [self penup];	[self plotto:xStart		:myTrigger];	[self plotto:xStop		:myTrigger];    [self penup];}- (void)        setTimerRunning:(BOOL)run sender:(id)sender{    if (!running && run) {        // If we're not running and we've been told to run, we'd        // better start the timer.  Set it up so that it calls        // our drawAnother: method periodically.        repeatTimer = [[NSTimer scheduledTimerWithTimeInterval:0.0                            target:self                            selector:@selector(drawAnother:)                            userInfo:nil                            repeats:YES            	      ] retain];        running = YES;    } else if (running && !run) {        // We're running and we've been told not to, so let's stop.                [repeatTimer invalidate];        [repeatTimer release];        repeatTimer = nil;        running = NO;    }}- (IBAction)			changeTest:(id)sender{	samplingPeriod = [sender doubleValue];	if (0.001 > samplingPeriod) {		samplingPeriod = 0.001;		[sender setDoubleValue:samplingPeriod];	}}- (IBAction)			changeStart:(id)sender{	if ([sender intValue]) {		[self setTimerRunning:YES sender:self];	} else {		[self setTimerRunning:NO sender:self];	}}- (IBAction)			restart:(id)sender{    [self setNeedsDisplay: YES];	}- (void)dealloc {	[self setTimerRunning:NO sender:self];    [backgroundColor release];    [super dealloc];}@end