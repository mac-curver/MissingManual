#import		"MyDocument.h"#import 	"ScientificImage.h"#import 	"ImageAxis.h"#import 	"HorizontalImageAxis.h"#import 	"VerticalImageAxis.h"#import		"MyDocument.h"#import		"MyImageView.h"@implementation MyImageViewdouble			myTriggerLevel;double			yScale = 128;double			yOffset = 0;float			*audioBuffer = nil;int				audioLength = 0;#pragma mark --- Implementation ---- (void)awakeFromNib{		[super awakeFromNib];		[self setImageScaling:NSScaleToFit];	[self sizeDidChange:nil];		[self changeTiming:timingSlider];	[self changeTriggerPosition:triggerPositionText];	//[self changeTriggerMode:(id)sender];		[self changeTriggerLevel:triggerLevelText];	[self changeOffset:yOffsetSlider];	[self changeScale:yScaleSlider];	[self changeRemanenz: remanenzPopUpButton];	    xStart			= 0.0;	xStop			= pow(10, -[timingSlider doubleValue]/5);	[self windowFromX:xStart ToX:xStop AndFromY:yScale*(yOffset-1) ToY:yScale*(yOffset+1)];	overPrint = 0;	repeatTimer = nil;	state = 0;	samplingPeriod  = 0.1;			if (1 == 1) {		grabber = [[SoundInputGrabber alloc] initWithDelegate:self callbackSelector:@selector(initAudioBuffer:)];    	}	[self		setTimerRunning:[continousButton intValue]];}- (void)    initAudioBuffer:(AudioBuffer *)AUbuffer{	audioBuffer = (float*)AUbuffer->mData;	audioLength = AUbuffer->mDataByteSize>>2;	//[self		setTimerRunning:YES];	//[self performSelector:@selector(drawAudioBuffer)];// forces crashes}- (void)    drawAnother:(id)timer{	if (0 != audioLength) {		[self drawAudioBuffer];	} else {		[self drawCharBuffer];	}}- (void)    drawAudioBuffer{		double          x = 0;    double          value = 0;    static int		oneRowCount = 0;	int				oneRowCountLeft = 0;	//double			y1, y2;	enum			{waitForLow, waitForHigh, triggered};	enum			{autoTrigger, normalTrigger, singleTrigger};	enum			{edgeHighLow, edgeLowHigh, smart};	//static int		triggerFormat = edgeLowHigh;	//static int		triggerMode = autoTrigger;	static int		triggerState = triggered;//waitForLow;	BOOL			triggerOk = false;		if ([[self window] isVisible] && (0 != audioLength)) {		// can not access document anymore if closed!		[self lineWidth:0.5];		myTriggerLevel = 0.006;				// draw the values filtered		switch (triggerState) {			case waitForLow:				for (x = 0; x < 2*xStop/samplingPeriod; x++) {					value = audioBuffer[oneRowCount % audioLength];					if (value < myTriggerLevel) {						triggerState = waitForHigh;						goto WaitForHigh;						break;					}					oneRowCount+=2;				}				goto Triggered;				break;			case waitForHigh:		WaitForHigh:				triggerState = waitForLow;				for (x = 0; x < xStop/samplingPeriod; x++) {					oneRowCount+=2;					value = audioBuffer[oneRowCount % audioLength];					if (value > myTriggerLevel) {						triggerState = triggered;						triggerOk = true;						goto Triggered;						break;					}				}				goto Triggered;				break;			case triggered:		Triggered:				[currentImage	lockFocus];									// Draw on the new Image.				if (state > 0) {//[remanenzText intValue]) {					myWhite = [whiteText doubleValue];					[[NSColor colorWithDeviceRed:1.0 green:1.0 blue:1.0 alpha:myAlpha] set];					NSRectFillUsingOperation([self bounds], NSCompositePlusLighter);					state = 1;				} else {					state++;				}				[[NSColor colorWithDeviceRed:0.0f green:0.0f blue:0.0f alpha:1.0] set];				oneRowCount += audioLength;				if (triggerOk) {					xStart = samplingPeriod*(myTriggerLevel-audioBuffer[(oneRowCount) % audioLength])/(audioBuffer[(oneRowCount+0) % audioLength]-audioBuffer[(oneRowCount+2) % audioLength]);					if (0 > xStart) {						xStart = 0;					}				} else {					xStart = 0;				}				oneRowCountLeft = oneRowCount;				[self penup];				for (x = xStart; x < xStop; x+=samplingPeriod) {					value = audioBuffer[oneRowCount % audioLength]*10240;					[self plotto:x					:value];					//[self plotto:x+samplingPeriod   :value];					oneRowCount+=2;				}				oneRowCount = oneRowCountLeft+1;				[[NSColor blueColor] set];				[self penup];				for (x = xStart; x < xStop; x+=samplingPeriod) {					value = audioBuffer[oneRowCount % audioLength]*10240;					[self plotto:x					:value];					//[self plotto:x+samplingPeriod   :value];					oneRowCount+=2;				}				[currentImage unlockFocus];									//  Have to balance the -lockFocus/-unlockFocus calls.							NSImage	*bkgImage = [[NSImage alloc] initWithSize:mySize];	//  background picture, the same size as this one				[bkgImage lockFocus];										//  -lockFocus				[gridImage compositeToPoint:NSZeroPoint operation:NSCompositeCopy]; 				myCompositeMode = [compositeModeText intValue];				[currentImage compositeToPoint:NSZeroPoint operation:myCompositeMode]; 					[self lineWidth:1.2];				[[NSColor redColor] set];				[self penup];				[self plotto:xStart		:myTriggerLevel];				[self plotto:xStop		:myTriggerLevel];				[bkgImage unlockFocus];										//  Have to balance the -lockFocus/-unlockFocus calls.				[bkgImage	autorelease];									// Always balance the -retain/-release calls.				[self		setImage:bkgImage];				overPrint ++;				triggerState = waitForLow;				break;		}	}	audioLength = 0;}/*- (void)drawRect:(NSRect)aRect is not allowed!!!{	[self drawAnother:repeatTimer];}*/- (void)    drawCharBuffer{	double          x = 0;    double          value = 0;    static int		oneRowCount = 0;	//double			y1, y2;	unsigned		myLength;	enum			{waitForLow, waitForHigh, triggered};	enum			{autoTrigger, normalTrigger, singleTrigger};	enum			{edgeHighLow, edgeLowHigh, smart};	//static int		triggerFormat = edgeLowHigh;	//static int		triggerMode = autoTrigger;	static int		triggerState = waitForLow;	BOOL			triggerOk = false;	char			*myBuffer;		if ([/*nil !=*/ [self window] isVisible /*isKeyWindow*/ /*isMainWindow*/]) {		// can not access document anymore if closed!		myBuffer = [myDocument buffer];		if (myBuffer) {														// check if budffer is not empty						myLength  = [myDocument length];			[self lineWidth:0.5];						// draw the values filtered			switch (triggerState) {				case waitForLow:					for (x = 0; x < 2*xStop/samplingPeriod; x++) {						value = myBuffer[oneRowCount % myLength];						if (value < myTriggerLevel) {							triggerState = waitForHigh;							goto WaitForHigh;							break;						}						oneRowCount++;					}					goto Triggered;					break;				case waitForHigh:			WaitForHigh:					triggerState = waitForLow;					for (x = 0; x < xStop/samplingPeriod; x++) {						oneRowCount++;						value = myBuffer[oneRowCount % myLength];						if (value > myTriggerLevel) {							triggerState = triggered;							triggerOk = true;							goto Triggered;							break;						}					}					goto Triggered;					break;				case triggered:			Triggered:					myDensity = [densityText doubleValue];					[currentImage	lockFocus];									// Draw on the new Image.					if (state > 0) {//[remanenzText intValue]) {						myWhite = [whiteText doubleValue];						[[NSColor colorWithDeviceRed:1.0 green:1.0 blue:1.0 alpha:myAlpha] set];						NSRectFillUsingOperation([self bounds], NSCompositePlusLighter);						state = 1;					} else {						state++;					}					[[NSColor colorWithDeviceRed:0.0f green:0.0f blue:0.0f alpha:1.0] set];					[self penup];					oneRowCount += myLength-1;					if (triggerOk) {						xStart = samplingPeriod*(myTriggerLevel-myBuffer[(oneRowCount) % myLength])/(myBuffer[(oneRowCount+0) % myLength]-myBuffer[(oneRowCount+1) % myLength]);					} else {						xStart = 0;					}					if (0 != audioLength) {						for (x = xStart; x < xStop; x+=samplingPeriod) {							value = audioBuffer[oneRowCount % audioLength]*10240;							[self plotto:x					:value];							//[self plotto:x+samplingPeriod   :value];							oneRowCount++;						}					} else {						for (x = xStart; x < xStop; x+=samplingPeriod) {							value = myBuffer[oneRowCount % myLength];							[self plotto:x					:value];							//[self plotto:x+samplingPeriod   :value];							oneRowCount++;						}					}					[currentImage unlockFocus];									//  Have to balance the -lockFocus/-unlockFocus calls.									NSImage	*bkgImage = [[NSImage alloc] initWithSize:mySize];	//  background picture, the same size as this one					[bkgImage lockFocus];										//  -lockFocus					[gridImage compositeToPoint:NSZeroPoint operation:NSCompositeCopy]; 					myCompositeMode = [compositeModeText intValue];					[currentImage compositeToPoint:NSZeroPoint operation:myCompositeMode]; 						[self lineWidth:1.2];					[[NSColor redColor] set];					[self penup];					[self plotto:xStart		:myTriggerLevel];					[self plotto:xStop		:myTriggerLevel];					[bkgImage unlockFocus];										//  Have to balance the -lockFocus/-unlockFocus calls.					[bkgImage	autorelease];									// Always balance the -retain/-release calls.					[self		setImage:bkgImage];					overPrint ++;					triggerState = waitForLow;					break;			}		}	}}- (void)		drawAxis{    float			gridLineWidth = 0.5;	[gridImage	lockFocus];										// Draw on the new Image.    [self		choosePrimary];	NSRectFillUsingOperation([self bounds], NSCompositeClear);    [horizontalAxis	setGridRect:&windowRect];    [verticalAxis	setGridRect:&windowRect];                [[NSColor greenColor] set];    // draw x and y axis for primary plot    [horizontalAxis	linTics:windowRect.origin.y separation:0.0 ticPercent:200 andMajorEvery:10 lineWidth:gridLineWidth];     [verticalAxis	linTics:windowRect.origin.x separation:0.0 ticPercent:200 andMajorEvery:10 lineWidth:gridLineWidth];	[gridImage	unlockFocus];									//  Have to balance the -lockFocus/-unlockFocus calls.                            }- (void)        setTimerRunning:(BOOL)run{    // Test if repeatTimer does not exists, but it should and creates a new timer instance in this case	if ((nil == repeatTimer) && run) {        repeatTimer = [[NSTimer scheduledTimerWithTimeInterval:0.0                            target:self                            selector:@selector(drawAnother:)                            userInfo:nil                            repeats:YES            	      ] retain];    } else if ((nil != repeatTimer)  && !run) {		// remove timer instance when we stopped        [repeatTimer invalidate];        [repeatTimer release];        repeatTimer = nil;    }}// as responder to NSViewBoundsDidChangeNotification- (void)				sizeDidChange:(NSNotification *)notification{	mySize = [self bounds].size;		if (currentImage) {		[currentImage	release];	}	currentImage	= [[NSImage alloc] initWithSize:mySize];	//  actual image	[currentImage	retain];	//[currentImage	setScalesWhenResized:YES];		if (gridImage) {		[gridImage		release];	}	gridImage		= [[NSImage alloc] initWithSize:mySize];	//  image from grid	[gridImage		retain];	//[gridImage		setScalesWhenResized:YES];	[self			drawAxis];}#pragma mark --- IBAction ---- (IBAction)    drawHistogram:(id)sender{    double          value = 0;    static int		oneRowCount = 0;	unsigned		myLength;	char			*myBuffer;	char			*zeroes;	int				i;	double			lastZeroPos, zeroPos, rll;		int				lastPositive, positive;	//char			*topRLL, *bottomRLL;	//int				*topCount, *bottomCount;	//double			T = 64.0/11.0;												// T period in 		[self		setTimerRunning:NO];	if ([[self window] isVisible]) {											// can not access document anymore if closed!		myBuffer = [myDocument buffer];		if (myBuffer) {															// check if budffer is not empty						myLength  = 200; //[myDocument length];			zeroes = malloc(myLength);			zeroes[0] = 0; 			lastPositive = myBuffer[0] >= 0;			lastZeroPos = 0;			for (i = 1; i < myLength; i++) {				positive = myBuffer[i] >= 0;				if (positive) {					if (!lastPositive) {						zeroPos = i-myBuffer[i]/(myBuffer[i+1]-myBuffer[i]);						rll = zeroPos - lastZeroPos;						lastZeroPos = zeroPos;					}				} else {					if (lastPositive) {						zeroPos = i-myBuffer[i]/(myBuffer[i+1]-myBuffer[i]);						rll = zeroPos - lastZeroPos;						lastZeroPos = zeroPos;					}				}				lastPositive = positive;				zeroes[i] = zeroPos;			}			[currentImage	lockFocus];											// Draw on the new Image.			[self lineWidth:0.5];						[self penup];			for (oneRowCount = 0; oneRowCount < myLength; oneRowCount++) {				value = zeroes[oneRowCount];				[self plotto:oneRowCount	:value];				[self plotto:oneRowCount+1  :value];			}			[currentImage unlockFocus];											//  Have to balance the -lockFocus/-unlockFocus calls.			/*			NSImage	*bkgImage = [[NSImage alloc] initWithSize:mySize];			//  background picture, the same size as this one			[bkgImage lockFocus];												//  -lockFocus			myCompositeMode = [compositeModeText intValue];			[currentImage compositeToPoint:NSZeroPoint operation:myCompositeMode]; 				[self lineWidth:1.2];			[[NSColor blackColor] set];			[self penup];			[self plotto:xStart		:myTriggerLevel];			[self plotto:xStop		:myTriggerLevel];			[bkgImage unlockFocus];												//  Have to balance the -lockFocus/-unlockFocus calls.			[bkgImage	autorelease];											// Always balance the -retain/-release calls.			*/			free(zeroes); 			//[self		setImage:currentImage];						}	}}- (IBAction)			changeStart:(id)sender{	if ([sender intValue]) {		[self setTimerRunning:YES];	} else {		[self setTimerRunning:NO];	}}- (IBAction)			doAudio:(id)sender{	audioLength = 0;		if (0 == [sender intValue]) {		[grabber start];		[test setIntValue:99];	} else {		[grabber stop];		[test setIntValue:-99];	}}- (IBAction)			doTrigger:(id)sender{	[self drawAnother:repeatTimer];}- (IBAction)			changeTriggerLevel:(id)sender{	myTriggerLevel = [sender intValue];	[self		drawAnother:repeatTimer];}- (IBAction)			changeTriggerPosition:(id)sender{}- (IBAction)			changeTriggerMode:(id)sender{}- (IBAction)			changeTiming:(id)sender{	xStop = floor(pow(10, -[sender doubleValue]/5));	[self		windowFromX:xStart ToX:xStop AndFromY:yScale*(yOffset-1) ToY:yScale*(yOffset+1)];	[self		drawAxis];	[self		drawAnother:repeatTimer];}- (IBAction)			changeOffset:(id)sender{	yOffset = -[sender doubleValue];	[self		windowFromX:xStart ToX:xStop AndFromY:yScale*(yOffset-1) ToY:yScale*(yOffset+1)];	[self		drawAxis];	[self		drawAnother:repeatTimer];}- (IBAction)			changeScale:(id)sender{	yScale = pow(10, -[sender doubleValue]/5);	[self		windowFromX:xStart ToX:xStop AndFromY:yScale*(yOffset-1) ToY:yScale*(yOffset+1)];	[self		drawAxis];	[self		drawAnother:repeatTimer];}- (IBAction)			changeRemanenz:(id)sender{	switch ([sender indexOfSelectedItem]) {		case 0:			myAlpha = 1;			break;		case 1:			myAlpha = 0.5;			break;		case 2:			myAlpha = 0.25;			break;		case 3:			myAlpha = 0.128;			break;		case 4:			myAlpha = 0.064;			break;		case 5:			myAlpha = 0.032;			break;		case 6:			myAlpha = 0.016;			break;		case 7:			myAlpha = 0.008;			break;		case 8:			myAlpha = 0.004;			break;		case 9:			myAlpha = 0.002;			break;		case 10:			myAlpha = 0;			break;	}}#pragma mark --- Clean up ---- (void) dealloc{	[self setTimerRunning:NO];		[currentImage	release];	[gridImage		release];	    [grabber release];	[super dealloc];}@end