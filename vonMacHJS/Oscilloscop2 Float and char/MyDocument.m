////  MyDocument.m//  Oscilloscop2////  Created by Heinz-Jšrg on Sun Feb 22 2004.//  Copyright (c) 2004 __MyCompanyName__. All rights reserved.//#import		"MyDocument.h"#import		"NumberEntry.h"@implementation MyDocument- (id)init{    int			i;		self = [super init];    if (self) {            // Add your subclass-specific initialization here.        // If an error occurs here, send a [self release] message and return nil.		for (i = 0; i < 4; i++) {			channel[i] = nil;			length[i]  = 0;		}    }    return self;}- (NSString *)windowNibName{    // Override returning the nib file name of the document    // If you need to use a subclass of NSWindowController or if your document supports multiple NSWindowControllers, you should remove this method and override -makeWindowControllers instead.    return @"MyDocument";}- (void)windowControllerDidLoadNib:(NSWindowController *) aController{    int			i;		[super windowControllerDidLoadNib:aController];    // Add any code here that needs to be executed once the windowController has loaded the document's window.	for (i = 0; i < 4; i++) {		if (nil == channel[i]) {			length[i] = 512*8;			channel[i] = malloc(length[i]);		}	}}- (NSData *)dataRepresentationOfType:(NSString *)aType{    // Insert code here to write your document from the given data.  You can also choose to override -fileWrapperRepresentationOfType: or -writeToFile:ofType: instead.    return nil;}- (BOOL)loadDataRepresentation:(NSData *)data ofType:(NSString *)aType{	NSRange				myRange;	const unsigned int  headerSize = 357;	Boolean				fileTypeRecognized = NO;	    if ([aType isEqualToString:@"JPEG"])  {		//[originalImageView setImage:[[[NSImage alloc] initWithContentsOfFile:[sheet filename]]autorelease]];		[originalImageView setImage:[[NSImage alloc] initWithData:data]];		        fileTypeRecognized = YES;	} else {	/* ([aType isEqualToString:@"LeCroyA"] || [aType isEqualToString:@"LeCroyB"] ||		[aType isEqualToString:@"LeCroyC"] || [aType isEqualToString:@"LeCroyD"] ||		[aType isEqualToString:@"LeCroyE"] || [aType isEqualToString:@"LeCroyT"]) */		NSString		*pathName = [self fileName];		NSMutableArray	*pathComponents = (NSMutableArray*)[pathName pathComponents];		unsigned		lastIndex = [pathComponents count]-1;		NSMutableString	*fileName = [NSMutableString stringWithString:[pathComponents objectAtIndex:lastIndex]];		NSCharacterSet	*pointSet = [NSCharacterSet characterSetWithCharactersInString:@"."];		NSRange			pointRange = [fileName rangeOfCharacterFromSet:pointSet];				pointRange.location--;		pointRange.length = 1;		int				i;		for (i = 0; i < 2; i++) {						NSString		*channelString = [NSString  stringWithFormat:@"%d", i+1];			char			*charBuffer;			[fileName replaceCharactersInRange:pointRange withString:channelString];			[pathComponents replaceObjectAtIndex:lastIndex withObject:fileName];			NSString		*newAbsPathName = [NSString pathWithComponents:pathComponents];			NSData			*myData = [NSData dataWithContentsOfFile:newAbsPathName];			myRange = NSMakeRange(0, headerSize);			[myData getBytes:(void*)myHeader range:myRange];					length[i]  =		   [myData length]-headerSize;			channel[i] = malloc(length[i]*sizeof(float));			charBuffer = malloc(length[i]);			myRange = NSMakeRange(headerSize, length[i]);			[myData getBytes:(void*)charBuffer range:myRange];			int		k;			for (k = 0; k < length[i]; k++) {				channel[i][k] = 1.0*charBuffer[k];			}		}		/*		myRange = NSMakeRange(0, headerSize);		[data getBytes:(void*)myHeader range:myRange];				lengthA  =		   [data length]-headerSize;		channelA = malloc(lengthA);		myRange = NSMakeRange(headerSize, lengthA);		[data getBytes:(void*)channelA range:myRange];		*/		        fileTypeRecognized = YES;    }	return fileTypeRecognized;}- (char*)   header{	return  myHeader;}#ifdef CHAR- (char*)		channel:(unsigned)number#else- (float*)		channel:(unsigned)number#endif{	return  channel[number];}- (unsigned)	length:(unsigned)number{	return  length[number];}- (void)dealloc {	int			i;		for (i = 0; i < 4; i++) {		if (channel[i]) free(channel[i]);	}    [super dealloc];}@end