////  MyDocument.m//  Oscilloscop2////  Created by Heinz-Jšrg on Sun Jun 1 2003.//  Copyright (c) 2003 Heinz-Jšrg SCHR…DER. All rights reserved.////	Version 1.30: 28.12.2004		all double replaced by float!#import 	"ScientificImage.h"#import 	"ImageAxis.h"#import 	"HorizontalImageAxis.h"#import 	"VerticalImageAxis.h"#import		"MyImageView.h"#import		"MyDocument.h"#import		"NumberEntry.h"@implementation MyDocumentenum {	none = 0,	pictureType,	lecroyType,	audioType};	- (id)init{    int			i;		self = [super init];    if (self) {            // Add your subclass-specific initialization here.        // If an error occurs here, send a [self release] message and return nil.		for (i = 0; i < 4; i++) {			channel[i] = nil;			length[i]  = 0;		}		myFileType = audioType;    }    return self;}- (NSString *)windowNibName{    // Override returning the nib file name of the document    // If you need to use a subclass of NSWindowController or if your document supports multiple NSWindowControllers, 	// you should remove this method and override -makeWindowControllers instead.    return @"MyDocument";}- (void)windowControllerDidLoadNib:(NSWindowController *) aController{    int			i;		[super windowControllerDidLoadNib:aController];    // Add any code here that needs to be executed once the windowController has loaded the document's window.	switch (myFileType) {		case 		pictureType:			[originalImageView setImage:myImage];			break;		case		lecroyType:			break;		case		audioType:			for (i = 0; i < 2; i++) {				if (nil == channel[i]) {					length[i] = 8192;					channel[i] = malloc(length[i]*sizeof(float));				}			}			break;	}	[originalImageView				enableChannel:0 enabled:(nil != channel[0])];	[originalImageView				enableChannel:1 enabled:(nil != channel[1])];	[originalImageView				enableChannel:2 enabled:(nil != channel[2])];	[originalImageView				enableChannel:3 enabled:(nil != channel[3])];}- (NSData *)dataRepresentationOfType:(NSString *)aType{    // Insert code here to write your document from the given data.  You can also choose to override -fileWrapperRepresentationOfType: or -writeToFile:ofType: instead.    return nil;}- (void)loadBinaryHeader:(NSData *)data length:(unsigned)size{	NSRange				myRange = NSMakeRange(0, size);							// range for header suppression					[data getBytes:(void*)myHeader range:myRange];								// last file loaded overwrites the header!!!}- (void)loadBinaryData:(NSData *)myData start:(unsigned)start end:(unsigned)end of:(unsigned)channelNumber {	NSRange				myRange;												// range to get the bytes	char				*charBuffer;											// byte buffer		length[channelNumber]  = end-start;											// file length without header	channel[channelNumber] = malloc(length[channelNumber]*sizeof(float));	charBuffer = malloc(length[channelNumber]);													myRange = NSMakeRange(start, length[channelNumber]);	[myData getBytes:(void*)charBuffer range:myRange];							// 	int		k;	for (k = 0; k < length[channelNumber]; k++) {		channel[channelNumber][k] = charBuffer[k]/256.0;						// copy data into correct format (scaling for 1Volt!!!)	}	free(charBuffer);}- (BOOL)loadDataRepresentation:(NSData *)data ofType:(NSString *)aType{	const unsigned int  headerSize = 357;										// header size for template from LeCroy	Boolean				fileTypeRecognized = NO;								// returns YES		    if ([aType isEqualToString:@"JPEG"])  {		myFileType = pictureType;		myImage = [[NSImage alloc] initWithData:data];		        fileTypeRecognized = YES;	} else {	/* ([aType isEqualToString:@"LeCroyA"] || [aType isEqualToString:@"LeCroyB"] ||		[aType isEqualToString:@"LeCroyC"] || [aType isEqualToString:@"LeCroyD"] ||		[aType isEqualToString:@"LeCroyE"] || [aType isEqualToString:@"LeCroyT"]) */		NSString		*pathName = [self fileName];		NSMutableArray	*pathComponents = (NSMutableArray*)[pathName pathComponents];		unsigned		lastIndex = [pathComponents count]-1;		NSMutableString	*fileName = [NSMutableString stringWithString:[pathComponents objectAtIndex:lastIndex]];		NSCharacterSet	*pointSet = [NSCharacterSet characterSetWithCharactersInString:@"."];		NSRange			pointRange = [fileName rangeOfCharacterFromSet:pointSet];				pointRange.location--;		pointRange.length = 1;				int				i;		for (i = 0; i < 4; i++) {															// load up to 4 channels			NSString		*channelString = [NSString  stringWithFormat:@"%d", i+1];		// produce channel number string			[fileName replaceCharactersInRange:pointRange withString:channelString];		// filenames like SC1.000, SC2.000, SC3.000, SC4.000			[pathComponents replaceObjectAtIndex:lastIndex withObject:fileName];			// 			NSString		*newAbsPathName = [NSString pathWithComponents:pathComponents];	// compose filenames from components			NSData			*myData = [NSData dataWithContentsOfFile:newAbsPathName];		// load the data						if (0 != [myData bytes]) {																// empty if file does not exists				[self loadBinaryHeader:myData length:headerSize];							// range for header suppression				[self loadBinaryData:myData start:headerSize end:[myData length] of:i];				fileTypeRecognized = YES;			}		}		if (!fileTypeRecognized) {												// file loading above did not succeed load...			[self loadBinaryHeader:data length:headerSize];						// range for header suppression			[self loadBinaryData:data start:headerSize end:[data length] of:0];		}		myFileType = lecroyType;        fileTypeRecognized = YES;    }	return fileTypeRecognized;}- (char*)   header{	return  myHeader;}- (float*)		channel:(unsigned)number{	return  channel[number];}- (unsigned)	length:(unsigned)number{	return  length[number];}- (void)dealloc {	int			i;		[myImage			release];	[originalImageView	stopAudio];			// we need to stop grabber before relesing the buffer	for (i = 0; i < 4; i++) {		if (channel[i]) free(channel[i]);	}    [super dealloc];}@end