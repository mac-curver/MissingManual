////  MyImageView.m//  Oscilloscope////  Created by Heinz-Jšrg on Sun Jun 1 2003.//  Copyright (c) 2003 Heinz-Jšrg SCHR…DER. All rights reserved.////	Version 1.30: 28.12.2004		all double replaced by float!#import		"MyDocument.h"#import 	"ScientificImage.h"#import 	"ImageAxis.h"#import 	"HorizontalImageAxis.h"#import 	"VerticalImageAxis.h"#import		"MyImageView.h"#import		"msClock.h"@implementation MyImageViewdouble			myTriggerLevel;double			yScale = 128;double			yOffset = 0;#pragma mark --- Implementation ---- (void)awakeFromNib{		int			myTag;		initiated = NO;		[super awakeFromNib];		[self colorChannel0:colorChannel0];	[self colorChannel1:colorChannel1];	[self colorChannel2:colorChannel2];	[self colorChannel3:colorChannel3];	[self colorGrid:colorWellGrid];	[self colorBckgnd:colorWellBckgnd];	[self colorCursor:colorWellCursor];	[self colorSpecial:colorWellSpecial];    xStart			= 0.0;	xStop			= pow(10, -[timingSlider doubleValue]/5);	oneRowCount		= 0;	[self setImageScaling:NSScaleToFit];	[self sizeDidChange:nil];	[self changeRemanenz: remanenzPopUpButton];				NSButton		*curButton;		for (myTag = 0; myTag < 4; myTag ++) {		curButton = [channelMatrix cellWithTag:myTag];		channelDisplay[myTag] = [curButton state];		[yOffsetMatrix selectCellWithTag:myTag];		[self changeOffsetMatrix:yOffsetMatrix];		[yScaleMatrix selectCellWithTag:myTag];		[self changeScaleMatrix:yScaleMatrix];	}	[self changeTiming:timingSlider];	[self changeTriggerPosition:triggerPositionText];	//[self changeTriggerMode:(id)sender];		[self changeTriggerLevel:triggerLevelText];	[self changeTriggerChannel:triggerMatrix];	overPrint = 0;	repeatTimer = nil;	state = 0;	samplingPeriod  = 0.1;	displayIsRunning = FALSE;			if (1 == 1) {		grabber = [[SoundInputGrabber alloc] initWithDelegate:self callbackSelector:@selector(initAudioBuffer:)];    	}	[self		setTimerRunning:[continousButton intValue]];	initiated = YES;	[self		drawFloatBuffer];}- (void)    initAudioBuffer:(AudioBuffer *)AUbuffer{	int				i; 	static int		j = 0;	float			*myLeftBuffer;	float			*myRightBuffer;	unsigned		length;	unsigned		bufferLength;	if (nil != myDocument) {		bufferLength = [myDocument length:0]-2*length;		myLeftBuffer  = [myDocument channel:0];		myRightBuffer = [myDocument channel:1];		length = AUbuffer->mDataByteSize>>2;									// size is float		for (i = 0; i < length; i += 2) {			myLeftBuffer[j]  = ((float*)AUbuffer->mData)[i]   * 4;			myRightBuffer[j] = ((float*)AUbuffer->mData)[i+1] * 4;			j ++;			if (bufferLength <= j) {				j = 0;				//[self drawFloatBuffer];			}		}	}}- (void)    drawAnother:(id)timer{	if ([[self window] isVisible] && !displayIsRunning) {					// can not access document anymore if closed!		[self drawFloatBuffer];	}}/*- (void)drawRect:(NSRect)aRect //is not allowed!!!{	[self drawAnother:repeatTimer];}*/- (unsigned)	nextTrigger{	double          x = 0;    double          value = 0;	unsigned		myLength;	enum			{waitForLow, waitForHigh, triggered};	enum			{autoTrigger, normalTrigger, singleTrigger};	enum			{edgeHighLow, edgeLowHigh, smart};	//static int		triggerFormat = edgeLowHigh;	//static int		triggerMode = autoTrigger;	static int		triggerState = waitForLow;	BOOL			triggerOk = false;	float			*myBuffer;		if (initiated) {		myBuffer = [myDocument channel:triggerChannel];		if (myBuffer) {														// check if budffer is not empty			myLength  = [myDocument length:0];			[self lineWidth:0.5];						// draw the values filtered			switch (triggerState) {				case waitForLow:					for (x = 0; x < 2*xStop/samplingPeriod; x++) {						value = myBuffer[oneRowCount % myLength];						if (value < myTriggerLevel) {							triggerState = waitForHigh;							goto WaitForHigh;							break;						}						oneRowCount++;					}					goto Triggered;					break;				case waitForHigh:			WaitForHigh:					triggerState = waitForLow;					for (x = 0; x < xStop/samplingPeriod; x++) {						oneRowCount++;						value = myBuffer[oneRowCount % myLength];						if (value > myTriggerLevel) {							triggerState = triggered;							triggerOk = true;							goto Triggered;							break;						}					}					goto Triggered;					break;				case triggered:			Triggered:					break;			}		}	}	return oneRowCount;}- (void)    drawFloatBuffer{	double          x = 0;    double          value = 0;	//double			y1, y2;	unsigned		myLength;	enum			{waitForLow, waitForHigh, triggered};	enum			{autoTrigger, normalTrigger, singleTrigger};	enum			{edgeHighLow, edgeLowHigh, smart};	//static int		triggerFormat = edgeLowHigh;	//static int		triggerMode = autoTrigger;	static int		triggerState = waitForLow;	BOOL			triggerOk = false;	float			*myBuffer;	int				i;		if (initiated) {		displayIsRunning = YES;		myBuffer = [myDocument channel:triggerChannel];		if (myBuffer) {														// check if budffer is not empty						myLength  = [myDocument length:0];			[self lineWidth:0.5];						// draw the values filtered			switch (triggerState) {				case waitForLow:					for (x = 0; x < 2*xStop/samplingPeriod; x++) {						value = myBuffer[oneRowCount % myLength];						if (value < myTriggerLevel) {							triggerState = waitForHigh;							goto WaitForHigh;							break;						}						oneRowCount++;					}					goto Triggered;					break;				case waitForHigh:			WaitForHigh:					triggerState = waitForLow;					for (x = 0; x < xStop/samplingPeriod; x++) {						oneRowCount++;						value = myBuffer[oneRowCount % myLength];						if (value > myTriggerLevel) {							triggerState = triggered;							triggerOk = true;							goto Triggered;							break;						}					}					goto Triggered;					break;				case triggered:			Triggered:					msClockReset();					myDensity = [densityText doubleValue];					[currentImage	lockFocus];									// Draw on the new Image.					if (state > 0) {//[remanenzText intValue]) {						//[[NSColor colorWithDeviceRed:1.0 green:1.0 blue:1.0 alpha:myAlpha] set];						[colorBckgnd set];						NSRectFillUsingOperation([self bounds], NSCompositePlusLighter);						state = 1;					} else {						state++;					}					//[self penup];					oneRowCount += myLength-1;					if (triggerOk) {						xStart = samplingPeriod*(myTriggerLevel-myBuffer[(oneRowCount) % myLength])/(myBuffer[(oneRowCount+0) % myLength]-myBuffer[(oneRowCount+1) % myLength]);					} else {						xStart = 0;					}					[self penup];					for (i = 0; i < 4; i++) {						if (channelDisplay[i]) {							[self		windowFromX:xStart ToX:xStop AndFromY:yScaleArray[i]*(yOffsetArray[i]-1) ToY:yScaleArray[i]*(yOffsetArray[i]+1)];							[self		choosePrimary];							myBuffer = [myDocument channel:i];							[colorChannel[i] set];							[self plotData:myBuffer startIndex:oneRowCount length:myLength from:xStart to:xStop increment:samplingPeriod];						}					}					oneRowCount += (xStop-xStart)/samplingPeriod;					[currentImage unlockFocus];									//  Have to balance the -lockFocus/-unlockFocus calls.									NSImage	*bkgImage = [[NSImage alloc] initWithSize:mySize];	//  background picture, the same size as this one					[bkgImage lockFocus];										//  -lockFocus					[gridImage compositeToPoint:NSZeroPoint operation:NSCompositeCopy]; 					myCompositeMode = [compositeModeText intValue];					[currentImage compositeToPoint:NSZeroPoint operation:myCompositeMode]; 						[self lineWidth:1.2];					[[NSColor redColor] set];					[self penup];					[self plotto:xStart		:myTriggerLevel];					[self plotto:xStop		:myTriggerLevel];					[bkgImage unlockFocus];										//  Have to balance the -lockFocus/-unlockFocus calls.					[bkgImage	autorelease];									// Always balance the -retain/-release calls.					[self		setImage:bkgImage];					overPrint ++;					triggerState = waitForLow;					[test setIntValue:msClock()];					break;			}		}	}	displayIsRunning = NO;}- (void)				enableChannel:(int)channel enabled:(Boolean)enabled{	// Attention the 4 channels are numbered from 0...3		NSButton *currentButton = (NSButton*)[channelMatrix  cellWithTag:channel];	[currentButton setEnabled:enabled];}- (void)		drawAxis{    // we are plotting a coordinate system taking the xScale from application and using the secondary axix	// to plot +/-5 vertical divisions	float			gridLineWidth = 0.5;	[gridImage	lockFocus];										// Draw on the new Image.	[self		secondaryFromX:xStart ToX:xStop AndFromY:-5 ToY:5];    [self		chooseSecondary];	NSRectFillUsingOperation([self bounds], NSCompositeClear);    [horizontalAxis	setGridRect:&windowRect];    [secondaryAxis	setGridRect:&windowRect];                [colorGrid set];    // draw x and y axis for primary plot    [horizontalAxis	linTics:windowRect.origin.y separation:0.0 ticPercent:200 andMajorEvery:10 lineWidth:gridLineWidth];     [secondaryAxis	linTics:windowRect.origin.x separation:1.0 ticPercent:200 andMajorEvery: 5 lineWidth:gridLineWidth];	[self		choosePrimary];	[gridImage	unlockFocus];									//  Have to balance the -lockFocus/-unlockFocus calls.                            }- (void)        setTimerRunning:(BOOL)run{    // Test if repeatTimer does not exists, but it should and creates a new timer instance in this case	if ((nil == repeatTimer) && run) {        repeatTimer = [[NSTimer scheduledTimerWithTimeInterval:0.0                            target:self                            selector:@selector(drawAnother:)                            userInfo:nil                            repeats:YES            	      ] retain];    } else if ((nil != repeatTimer)  && !run) {		// remove timer instance when we stopped        [repeatTimer invalidate];        [repeatTimer release];        repeatTimer = nil;    }}// as responder to NSViewBoundsDidChangeNotification- (void)				sizeDidChange:(NSNotification *)notification{	mySize = [self bounds].size;		if (currentImage) {		[currentImage	release];	}	currentImage	= [[NSImage alloc] initWithSize:mySize];	//  actual image	[currentImage	retain];	//[currentImage	setScalesWhenResized:YES];		if (gridImage) {		[gridImage		release];	}	gridImage		= [[NSImage alloc] initWithSize:mySize];	//  image from grid	[gridImage		retain];	//[gridImage		setScalesWhenResized:YES];	[self			drawAxis];}#pragma mark --- IBAction ---- (IBAction)    drawHistogram:(id)sender{    double          value = 0;	unsigned		myLength;	char			*zeroes;	int				i;	double			lastZeroPos, zeroPos, rll;		int				lastPositive, positive;	//char			*topRLL, *bottomRLL;	//int				*topCount, *bottomCount;	//double			T = 64.0/11.0;												// T period in 	float			*myBuffer;		[self		setTimerRunning:NO];	if ([[self window] isVisible]) {											// can not access document anymore if closed!		myBuffer = [myDocument channel:0];		if (myBuffer) {															// check if budffer is not empty						myLength  = 200; //[myDocument length];			zeroes = malloc(myLength);			zeroes[0] = 0; 			lastPositive = myBuffer[0] >= 0;			lastZeroPos = 0;			for (i = 1; i < myLength; i++) {				positive = myBuffer[i] >= 0;				if (positive) {					if (!lastPositive) {						zeroPos = i-myBuffer[i]/(myBuffer[i+1]-myBuffer[i]);						rll = zeroPos - lastZeroPos;						lastZeroPos = zeroPos;					}				} else {					if (lastPositive) {						zeroPos = i-myBuffer[i]/(myBuffer[i+1]-myBuffer[i]);						rll = zeroPos - lastZeroPos;						lastZeroPos = zeroPos;					}				}				lastPositive = positive;				zeroes[i] = zeroPos;			}			[currentImage	lockFocus];											// Draw on the new Image.			[self lineWidth:0.5];						[self penup];			for (oneRowCount = 0; oneRowCount < myLength; oneRowCount++) {				value = zeroes[oneRowCount];				[self plotto:oneRowCount	:value];				[self plotto:oneRowCount+1  :value];			}			[currentImage unlockFocus];											//  Have to balance the -lockFocus/-unlockFocus calls.			free(zeroes); 						}	}}- (IBAction)			changeStart:(id)sender{	if ([sender intValue]) {		[self setTimerRunning:YES];	} else {		[self setTimerRunning:NO];	}}- (IBAction)			doAudio:(id)sender{		if (0 == [sender intValue]) {		[grabber start];	} else {		[grabber stop];	}}- (void)				stopAudio{		[grabber stop];}- (IBAction)			doTrigger:(id)sender{	[self drawFloatBuffer];}- (IBAction)			changeRisingEdge:(id)sender{	isRisingEdge = [sender intValue];}- (IBAction)			changeTriggerChannel:(id)sender{	NSButton			*triggerButton = [sender selectedCell];	triggerChannel = [triggerButton tag];}- (IBAction)			changeTriggerLevel:(id)sender{	myTriggerLevel = [sender doubleValue];	[self		drawAnother:repeatTimer];}- (IBAction)			changeTriggerPosition:(id)sender{}- (IBAction)			changeTriggerMode:(id)sender{}- (IBAction)			changeTiming:(id)sender{	xStop = floor(pow(10, -[sender doubleValue]/5));	[self		windowFromX:xStart ToX:xStop AndFromY:yScale*(yOffset-1) ToY:yScale*(yOffset+1)];	[self		drawAxis];	[self		drawAnother:repeatTimer];}- (IBAction)			changeOffsetMatrix:(id)sender{	NSControl			*currentControl = [sender selectedCell];	int					myChannel		= [currentControl tag];	yOffsetArray[myChannel]				= -[currentControl floatValue];	[self drawFloatBuffer];}- (IBAction)			changeScaleMatrix:(id)sender{	NSControl			*currentControl = [sender selectedCell];	int					myChannel		= [currentControl tag];	yScaleArray[myChannel]				= pow(10, -[sender doubleValue]/5);	[self drawFloatBuffer];}- (IBAction)			changeChannel:(id)sender{	NSButton			*currentButton = [sender selectedCell];	int					currentTag     = [currentButton tag];		channelDisplay[currentTag] = [currentButton state];	[self drawFloatBuffer];}- (IBAction)			changeRemanenz:(id)sender{	switch ([sender indexOfSelectedItem]) {		case 0:			myAlpha = 1;			break;		case 1:			myAlpha = 0.5;			break;		case 2:			myAlpha = 0.25;			break;		case 3:			myAlpha = 0.128;			break;		case 4:			myAlpha = 0.064;			break;		case 5:			myAlpha = 0.032;			break;		case 6:			myAlpha = 0.016;			break;		case 7:			myAlpha = 0.008;			break;		case 8:			myAlpha = 0.004;			break;		case 9:			myAlpha = 0.002;			break;		case 10:			myAlpha = 0;			break;	}	NSColor	*myColorBckgnd = colorBckgnd;	colorBckgnd = [myColorBckgnd colorWithAlphaComponent:myAlpha];	[myColorBckgnd		release];	[colorBckgnd		retain];}- (IBAction)			colorChannel0:(id)sender{	colorChannel[0] = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorChannel1:(id)sender{	colorChannel[1] = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorChannel2:(id)sender{	colorChannel[2] = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorChannel3:(id)sender{	colorChannel[3] = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorM0:(id)sender{	colorM0 = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorM1:(id)sender{	colorM1 = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorM2:(id)sender{	colorM2 = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorM3:(id)sender{	colorM3 = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorGrid:(id)sender{	colorGrid = [sender color];	[self drawAxis];	[self drawFloatBuffer];}- (IBAction)			colorBckgnd:(id)sender{	colorBckgnd = [[sender color] colorWithAlphaComponent:myAlpha];	[colorBckgnd		retain];	[self drawFloatBuffer];}- (IBAction)			colorCursor:(id)sender{	colorCursor = [sender color];	[self drawFloatBuffer];}- (IBAction)			colorSpecial:(id)sender{	colorSpecial = [sender color];	[self drawFloatBuffer];}#pragma mark --- Clean up ---- (void) dealloc{	[self setTimerRunning:NO];    [grabber stop];    [grabber release];		[currentImage	release];	[gridImage		release];	[colorBckgnd	release];	[super dealloc];}@end