////  MyDocument.m//  Oscilloscop2////  Created by Heinz-Jšrg on Sun Jun 1 2003.//  Copyright (c) 2003 Heinz-Jšrg SCHR…DER. All rights reserved.////	Version 1.30: 28.12.2004		all double replaced by float!#import		"TriggerTransformer.h"#import 	"ScientificImage.h"#import 	"ImageAxis.h"#import 	"HorizontalImageAxis.h"#import 	"VerticalImageAxis.h"#import		"MyImageView.h"#import		"MyDocument.h"#import		"NumberEntry.h"@implementation MyDocumentenum {	none = 0,	pictureType,	lecroyType,	audioType};#define		REVERSE(x)	byteReverse((char*)&(x), sizeof(x))- (void) 		WaveDescriptorReverse{	REVERSE(myWaveDescriptor.commType);	REVERSE(myWaveDescriptor.commOrder);	REVERSE(myWaveDescriptor.waveDescriptorLength);	REVERSE(myWaveDescriptor.userTextLength);	REVERSE(myWaveDescriptor.resDescriptor1);	REVERSE(myWaveDescriptor.trigTimeLength);	REVERSE(myWaveDescriptor.riseTimeLength);	REVERSE(myWaveDescriptor.resArray1);	REVERSE(myWaveDescriptor.waveArray1Length);	REVERSE(myWaveDescriptor.waveArray2Length);	REVERSE(myWaveDescriptor.resArray2);	REVERSE(myWaveDescriptor.resArray3);	//myWaveDescriptor.instrumentName	REVERSE(myWaveDescriptor.instrumentNumber);	//myWaveDescriptor.traceLabel	REVERSE(myWaveDescriptor.reserved1);	REVERSE(myWaveDescriptor.reserved2);	REVERSE(myWaveDescriptor.waveArrayCount);	REVERSE(myWaveDescriptor.pntsPerScreen);	REVERSE(myWaveDescriptor.firstValidPoint);	REVERSE(myWaveDescriptor.lastValidPoint);	REVERSE(myWaveDescriptor.firstPoint);	REVERSE(myWaveDescriptor.sparsingFactor);	REVERSE(myWaveDescriptor.segmentIndex);	REVERSE(myWaveDescriptor.subArrayCount);	REVERSE(myWaveDescriptor.sweepsPerAcq);	REVERSE(myWaveDescriptor.pointsPerPair);	REVERSE(myWaveDescriptor.pairOffset);	REVERSE(myWaveDescriptor.verticalGain);	REVERSE(myWaveDescriptor.verticalOffset);	REVERSE(myWaveDescriptor.maxValue);	REVERSE(myWaveDescriptor.minValue);	REVERSE(myWaveDescriptor.nominalBits);	REVERSE(myWaveDescriptor.nomSubArrayCount);	REVERSE(myWaveDescriptor.horizInterval);	REVERSE(myWaveDescriptor.horizOffset);	REVERSE(myWaveDescriptor.pixelOffset);	//myWaveDescriptor.verticalUnit	//myWaveDescriptor.horizontalUnit	REVERSE(myWaveDescriptor.reserved3);	REVERSE(myWaveDescriptor.reserved4);		REVERSE(myWaveDescriptor.triggerTime.seconds);	REVERSE(myWaveDescriptor.triggerTime.years);	REVERSE(myWaveDescriptor.acqDuration);	REVERSE(myWaveDescriptor.recordType);	REVERSE(myWaveDescriptor.processingDone);	REVERSE(myWaveDescriptor.reserved5);	REVERSE(myWaveDescriptor.risSweeps);	REVERSE(myWaveDescriptor.timeBase);	REVERSE(myWaveDescriptor.verticalCoupling);	REVERSE(myWaveDescriptor.probeAttenuation);	REVERSE(myWaveDescriptor.fixedVerticalGain);	REVERSE(myWaveDescriptor.bandWidthLimit);	REVERSE(myWaveDescriptor.verticalVernier);	REVERSE(myWaveDescriptor.acqVertOffset);	REVERSE(myWaveDescriptor.waveSource);}- (void) addValueToArray:(NSString *)value forName:(NSString *)name ofType:(NSString *)type{	NSMutableDictionary		*myDict = [[NSMutableDictionary alloc] init];		[myDict		setObject:value forKey:@"Value"];	[myDict		setObject:name	forKey:@"Key"];	[myDict		setObject:type	forKey:@"Type"];	[myArray	addObject:myDict];	[myDict		release];}	- (id)init{    int			i;		self = [super init];    if (self) {		// create an autoreleased instance of our value transformer & register it with the name that we refer to it with		myTriggerTransformer = [[[TriggerTransformer alloc] init] retain];		[NSValueTransformer setValueTransformer:myTriggerTransformer forName:@"TriggerTransformer"];        // Add your subclass-specific initialization here.        // If an error occurs here, send a [self release] message and return nil.		for (i = 0; i < 4; i++) {			channel[i] = nil;			length[i]  = 0;		}		myFileType = audioType;				myArray = [[NSMutableArray alloc] init];				[self addValueToArray:[self descriptor] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[self template] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[self descLength] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[self instrumentName] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[NSString stringWithFormat:@"%f V/div", [self verticalGain]] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[NSString stringWithFormat:@"%f V/div", [self verticalGain]] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[NSString stringWithFormat:@"%f V", [self verticalOffset]] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[NSString stringWithFormat:@"%f s", [self horizontalInterval]] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[NSString stringWithFormat:@"%f s", [self horizontalOffset]] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[self triggerTime] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[NSString stringWithFormat:@"%f s/div", [self timeBase]] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[self coupling] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[NSString stringWithFormat:@"%f x",  [self fixedVerticalGain]] forName:@"descriptor" ofType:@"char[16]"];		[self addValueToArray:[self bandwidthLimit] forName:@"descriptor" ofType:@"char[16]"];	[[parameters cellWithTag: 0] setStringValue:[self descriptor]];	[[parameters cellWithTag: 1] setStringValue:[self template]];	[[parameters cellWithTag: 2] setIntValue:   [self descLength]];	[[parameters cellWithTag: 3] setStringValue:[self instrumentName]];	[[parameters cellWithTag: 4] setStringValue:];	[[parameters cellWithTag: 5] setStringValue:];	[[parameters cellWithTag: 6] setStringValue:];	[[parameters cellWithTag: 7] setStringValue:];	[[parameters cellWithTag: 8] setStringValue:];	[[parameters cellWithTag: 9] setStringValue:];	[[parameters cellWithTag:10] setStringValue:];	[[parameters cellWithTag:11] setStringValue:[NSString stringWithFormat:@"%f x",  [self fixedVerticalGain]]];	[[parameters cellWithTag:12] setStringValue:];	}    return self;}- (NSString *)windowNibName{    // Override returning the nib file name of the document    // If you need to use a subclass of NSWindowController or if your document supports multiple NSWindowControllers, 	// you should remove this method and override -makeWindowControllers instead.    return @"MyDocument";}- (void)windowControllerDidLoadNib:(NSWindowController *) aController{    int			i;		[super windowControllerDidLoadNib:aController];    // Add any code here that needs to be executed once the windowController has loaded the document's window.	switch (myFileType) {		case 		pictureType:			[originalImageView setImage:myImage];			break;		case		audioType:			for (i = 0; i < 2; i++) {				if (nil == channel[i]) {					length[i] = 8192;					channel[i] = malloc(length[i]*sizeof(float));				}			}			// fall through!		case		lecroyType:			[originalImageView				enableChannel:0 enabled:(nil != channel[0])];			[originalImageView				enableChannel:1 enabled:(nil != channel[1])];			[originalImageView				enableChannel:2 enabled:(nil != channel[2])];			[originalImageView				enableChannel:3 enabled:(nil != channel[3])];			[originalImageView				initFirstDisplay];			break;	}	[[parameters cellWithTag: 0] setStringValue:[self descriptor]];	[[parameters cellWithTag: 1] setStringValue:[self template]];	[[parameters cellWithTag: 2] setIntValue:   [self descLength]];	[[parameters cellWithTag: 3] setStringValue:[self instrumentName]];	[[parameters cellWithTag: 4] setStringValue:[NSString stringWithFormat:@"%f V/div", [self verticalGain]]];	[[parameters cellWithTag: 5] setStringValue:[NSString stringWithFormat:@"%f V", [self verticalOffset]]];	[[parameters cellWithTag: 6] setStringValue:[NSString stringWithFormat:@"%f s", [self horizontalInterval]]];	[[parameters cellWithTag: 7] setStringValue:[NSString stringWithFormat:@"%f s", [self horizontalOffset]]];	[[parameters cellWithTag: 8] setStringValue:[self triggerTime]];	[[parameters cellWithTag: 9] setStringValue:[NSString stringWithFormat:@"%f s/div", [self timeBase]]];	[[parameters cellWithTag:10] setStringValue:[self coupling]];	[[parameters cellWithTag:11] setStringValue:[NSString stringWithFormat:@"%f x",  [self fixedVerticalGain]]];	[[parameters cellWithTag:12] setStringValue:[self bandwidthLimit]];}- (NSData *)dataRepresentationOfType:(NSString *)aType{    // Insert code here to write your document from the given data.  You can also choose to override -fileWrapperRepresentationOfType: or -writeToFile:ofType: instead.    return nil;}- (void)loadBinaryHeader:(NSData *)data{	NSRange				snRange = NSMakeRange(0, 11);							// range for SN suppression	NSRange				descRange = NSMakeRange(11, sizeof(myWaveDescriptor));	// range for header	char				serialNumber[11];		[data getBytes:(void*)(&serialNumber) range:snRange];						// last file loaded overwrites the header!!!	[data getBytes:(void*)(&myWaveDescriptor) range:descRange];					// last file loaded overwrites the header!!!	if (0 != myWaveDescriptor.commOrder) {										// if != 0 intel low endian otherwise big endian		[self WaveDescriptorReverse];	}}- (void)loadBinaryData:(NSData *)myData  length:(unsigned)myLength of:(unsigned)channelNumber {	NSRange				myRange;												// range to get the bytes	char				*charBuffer;											// byte buffer		length[channelNumber]  = myLength;											// file length without header	channel[channelNumber] = malloc(length[channelNumber]*sizeof(float));	charBuffer = malloc(length[channelNumber]);													myRange = NSMakeRange(sizeof(myWaveDescriptor)+11, length[channelNumber]);	[myData getBytes:(void*)charBuffer range:myRange];							// 	int		k;	for (k = 0; k < length[channelNumber]; k++) {		channel[channelNumber][k] = charBuffer[k]/128.0;						// copy data into correct format (scaling for +/-1 Volt!!!)	}	free(charBuffer);}- (BOOL)loadDataRepresentation:(NSData *)data ofType:(NSString *)aType{	Boolean				fileTypeRecognized = NO;								// returns YES		//NSLog([data MIMEType]);		    if ([aType isEqualToString:@"JPEG"]			||		[aType isEqualToString:@"JPG"]			||		[aType isEqualToString:@"OS-Type-JPEG"]	)  {		myFileType = pictureType;		myImage = [[NSImage alloc] initWithData:data];		        fileTypeRecognized = YES;	} else {	/* ([aType isEqualToString:@"LeCroyA"] || [aType isEqualToString:@"LeCroyB"] ||		[aType isEqualToString:@"LeCroyC"] || [aType isEqualToString:@"LeCroyD"] ||		[aType isEqualToString:@"LeCroyE"] || [aType isEqualToString:@"LeCroyT"]) */		NSString		*pathName = [self fileName];		NSMutableArray	*pathComponents = (NSMutableArray*)[pathName pathComponents];		unsigned		lastIndex = [pathComponents count]-1;		NSMutableString	*fileName = [NSMutableString stringWithString:[pathComponents objectAtIndex:lastIndex]];		NSCharacterSet	*pointSet = [NSCharacterSet characterSetWithCharactersInString:@"."];		NSRange			pointRange = [fileName rangeOfCharacterFromSet:pointSet];				pointRange.location--;		pointRange.length = 1;				int				i;		for (i = 0; i < 4; i++) {															// load up to 4 channels			NSString		*channelString = [NSString  stringWithFormat:@"%d", i+1];		// produce channel number string			[fileName replaceCharactersInRange:pointRange withString:channelString];		// filenames like SC1.000, SC2.000, SC3.000, SC4.000			[pathComponents replaceObjectAtIndex:lastIndex withObject:fileName];			// 			NSString		*newAbsPathName = [NSString pathWithComponents:pathComponents];	// compose filenames from components			NSData			*myData = [NSData dataWithContentsOfFile:newAbsPathName];		// load the data						if (0 != [myData bytes]) {														// empty if file does not exists				[self loadBinaryHeader:myData];												// range for header suppression				[self loadBinaryData:myData length:[myData length] of:i];				fileTypeRecognized = YES;			}		}		if (!fileTypeRecognized) {												// file loading above did not succeed load...			[self loadBinaryHeader:data];										// range for header suppression			[self loadBinaryData:data length:[data length] of:0];		}		myFileType = lecroyType;        fileTypeRecognized = YES;    }	return fileTypeRecognized;}- (WaveDescriptor*)   header{	return  &myWaveDescriptor;}- (NSString*)	descriptor{	return [NSString stringWithCString:myWaveDescriptor.descriptor];}- (NSString*)	template{	return [NSString stringWithCString:myWaveDescriptor.template];}- (unsigned)	descLength{	return myWaveDescriptor.waveDescriptorLength;}- (NSString*)	instrumentName{	return [NSString stringWithCString:myWaveDescriptor.instrumentName];}- (double)	verticalGain{	return myWaveDescriptor.verticalGain;}- (double)	verticalOffset{	return myWaveDescriptor.verticalOffset;}- (double)	horizontalInterval{	return myWaveDescriptor.horizInterval;}- (double)	horizontalOffset{	return myWaveDescriptor.horizOffset;}- (NSString*)	triggerTime{	return @"00.00.0000 ...";}- (double)	timeBase{	unsigned	digit = myWaveDescriptor.timeBase % 3;	unsigned	base  = myWaveDescriptor.timeBase / 3;	double		value = 0;	switch (digit) {		case 0: 			value = 1E-9;			break;		case 1:			value = 2E-9;			break;		case 2:			value = 5E-9;			break;	}	value = value * pow(10, base);	return value;}- (NSString*)	coupling{	switch(myWaveDescriptor.verticalCoupling) {		case 0: 			return @"DC 50 Ohm";		case 1:			return @"ground";		case 2:			return @"DC 1 MOhm";		case 3:			return @"ground";		case 4:			return @"AC 1 MOhm";				}	return @"invalid";}- (double)	fixedVerticalGain{	unsigned	digit = myWaveDescriptor.fixedVerticalGain % 3;	unsigned	base  = myWaveDescriptor.fixedVerticalGain / 3;	double		value = 0;	switch (digit) {		case 0: 			value = 1E-6;			break;		case 1:			value = 2E-6;			break;		case 2:			value = 5E-6;			break;	}	value = value * pow(10, base);	return value;}- (NSString*)	bandwidthLimit{	switch(myWaveDescriptor.bandWidthLimit) {		case 0: 			return @"Off";		case 1:			return @"On";	}	return @"invalid";}- (float*)		channel:(unsigned)number{	return  channel[number];}- (unsigned)	length:(unsigned)number{	return  length[number];}- (id)tableView:(NSTableView *)theTableView 	objectValueForTableColumn:(NSTableColumn *)column    row:(int)rowIndex{	return [[myArray objectAtIndex:rowIndex] objectForKey:[column identifier]];}- (int)numberOfRowsInTableView:(NSTableView *)aTableView{    return [myArray count];}- (void)dealloc {	int			i;		[myImage			release];	[originalImageView	stopAudio];			// we need to stop grabber before relesing the buffer	for (i = 0; i < 4; i++) {		if (channel[i]) free(channel[i]);	}	[myArray	release];	[myTriggerTransformer release];    [super dealloc];}@end