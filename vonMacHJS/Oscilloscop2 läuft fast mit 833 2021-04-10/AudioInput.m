////  AudioInput.m//  Oscilloscop2////  Created by Heinz-Jšrg on 20.04.05.//  Copyright 2005 __MyCompanyName__. All rights reserved.////	Version 1.00: 30.04.2005		translated to X-Code 2#import "AudioInput.h"@implementation AudioInput (Private)// this is the audio processing callback.OSStatus appIOProc (AudioDeviceID  inDevice, const AudioTimeStamp*  inNow, 								const AudioBufferList*   inInputData, const AudioTimeStamp*  inInputTime, 								AudioBufferList*  outOutputData, const AudioTimeStamp* inOutputTime, 								void* dataPtr){   	AudioInput			*self = (AudioInput *)dataPtr;	unsigned			i;    unsigned			audioLength = 2*(self->deviceBufferSize / self->deviceFormat.mBytesPerFrame);    float				*audioIn = inInputData->mBuffers[0].mData;		// audioLength returns 2048, therefore we are copying in chunks of 2048/44100s = 46.4ms		for (i = 0; i < audioLength; i += 2) {		self->leftBuffer[self->inIndex]  = audioIn[i];		self->rightBuffer[self->inIndex] = audioIn[i+1];		self->inIndex ++;		if (self->bufferLength <= self->inIndex) {			self->inIndex = 0;		}	}        return kAudioHardwareNoError;     }@end@implementation AudioInput- (AudioInput*)	init{	if (self = [super init]) {        /* class-specific initialization goes here */    }    return		self;}- (void)		setupAudioLeft:(float *)leftChannel Right:(float *)rightChannel Size:(int)length{    OSStatus			err = kAudioHardwareNoError;    UInt32				count;	       //device			= kAudioDeviceUnknown;    device			= kAudioDevicePropertyScopeInput;	     initialized		= NO;       // get the default output device for the HAL    count = sizeof(device);		// it is required to pass the size of the data to be returned        /*    err =AudioObjectGetPropertyData(AudioObjectID inObjectID,                                    const AudioObjectPropertyAddress *inAddress,                                    UInt32 inQualifierDataSize,                                    const void *inQualifierData,                                    UInt32 *ioDataSize,                                    void *outData                                    );    */        err = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,  &count, (void *) &device);    if (err != kAudioHardwareNoError) {        fprintf(stderr, "get kAudioHardwarePropertyDefaultOutputDevice error%dd\n",(int) err);        return;    }            /*!     @function       AudioObjectGetPropertyData     @abstract       Queries an AudioObject to get the data of the given property and places it in     the provided buffer.     @param          inObjectID     The AudioObject to query.     @param          inAddress     An AudioObjectPropertyAddress indicating which property is being queried.     @param          inQualifierDataSize     A UInt32 indicating the size of the buffer pointed to by inQualifierData.     Note that not all properties require qualification, in which case this     value will be 0.     @param          inQualifierData,     A buffer of data to be used in determining the data of the property being     queried. Note that not all properties require qualification, in which case     this value will be NULL.     @param          ioDataSize     A UInt32 which on entry indicates the size of the buffer pointed to by     outData and on exit indicates how much of the buffer was used.     @param          outData     The buffer into which the AudioObject will put the data for the given     property.     @result         An OSStatus indicating success or failure.     //    extern OSStatus    AudioObjectGetPropertyData( AudioObjectID                       inObjectID,                               const AudioObjectPropertyAddress*   inAddress,                               UInt32                              inQualifierDataSize,                               const void*                         inQualifierData,                               UInt32*                             ioDataSize,                               void*                               outData)                            __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);    */        // get the buffersize that the default device uses for IO    count = sizeof(deviceBufferSize);	// it is required to pass the size of the data to be returned    err = AudioDeviceGetProperty(device, 0, false, kAudioDevicePropertyBufferSize, &count, &deviceBufferSize);    if (err != kAudioHardwareNoError) {        fprintf(stderr, "get kAudioDevicePropertyBufferSize error%dd\n",(int) err);        return;    }    fprintf(stderr, "deviceBufferSize =%ud\n",(unsigned int) deviceBufferSize);       // get a description of the data format used by the default device    count = sizeof(deviceFormat);	// it is required to pass the size of the data to be returned    err = AudioDeviceGetProperty(device, 0, false, kAudioDevicePropertyStreamFormat, &count, &deviceFormat);    if (err != kAudioHardwareNoError) {        fprintf(stderr, "get kAudioDevicePropertyStreamFormat error%dd\n",(int) err);        return;    }    if (deviceFormat.mFormatID != kAudioFormatLinearPCM) {    	fprintf(stderr, "mFormatID !=  kAudioFormatLinearPCM\n");        return;    }    if (!(deviceFormat.mFormatFlags & kLinearPCMFormatFlagIsFloat)) {    	fprintf(stderr, "Sorry, currently only works with float format....\n");        return;    }		bufferLength	= length;	inIndex			= 0;	leftBuffer		= leftChannel;	rightBuffer		= rightChannel;        initialized		= YES;		err = AudioDeviceAddIOProc(device, appIOProc, (void *) self);				// setup our device with an IO proc    if (err != kAudioHardwareNoError) {    	fprintf(stderr, "Unable to install AudioDevice procedure....\n");        return;    }    fprintf(stderr, "mSampleRate = %g\n", deviceFormat.mSampleRate);    fprintf(stderr, "mFormatFlags =%08XX\n",(unsigned int) deviceFormat.mFormatFlags);    fprintf(stderr, "mBytesPerPacket =%ud\n",(unsigned int) deviceFormat.mBytesPerPacket);    fprintf(stderr, "mFramesPerPacket =%ud\n",(unsigned int) deviceFormat.mFramesPerPacket);    fprintf(stderr, "mChannelsPerFrame =%ud\n",(unsigned int) deviceFormat.mChannelsPerFrame);    fprintf(stderr, "mBytesPerFrame =%ud\n",(unsigned int) deviceFormat.mBytesPerFrame);    fprintf(stderr, "mBitsPerChannel =%ud\n",(unsigned int) deviceFormat.mBitsPerChannel);}- (BOOL)		start{    OSStatus					err = kAudioHardwareNoError;    if (!initialized) return false;    if (soundRecording) return false;                err = AudioDeviceStart(device, appIOProc);									// start recording sound through the device    if (err != kAudioHardwareNoError) return false;    soundRecording = true;														// set the playing status global to true    return true;}- (BOOL)		stop{    OSStatus 	err = kAudioHardwareNoError;        if (!initialized) return false;    if (!soundRecording) return false;        err = AudioDeviceStop(device, appIOProc);									// stop recording sound through the device    if (err != kAudioHardwareNoError) return false;        soundRecording = false;														// set the playing status global to false    return true;}- (BOOL)		isRunning{	return	soundRecording;}- (unsigned)	inIndex{	return inIndex;}#pragma mark --- Clean up ---- (void)			dealloc{    OSStatus 	err = kAudioHardwareNoError;	    err = AudioDeviceDestroyIOProcID(device, appIOProc);						// remove the IO proc from the device    if (err != kAudioHardwareNoError) {    	fprintf(stderr, "Unable to remove AudioDevice procedure....\n");        return;    }	[super dealloc];} @end