////  ScientificView.m//  BodeDiagram////  Created by Heinz-Jšrg on Sun Jun 1 2003.//  Copyright (c) 2003-2021 Heinz-Jšrg SCHR…DER. All rights reserved.////  using awakeFromNib instead of initWithFrame              1.04.2012 HJS//      to obtain compatibility to Xcode 10//  initialzed variable removed from awakeFromNib           11.10.2005 HJS//	Even that frame and bounds can be used to scale I am//  using my own scaling allowing the line thickness to//  be in pixel, rather	than to be magnified by the//  scaling factor				                            11.10.2005 HJS//	frame replaced by bounds!!!								 1.10.2005 HJS#import "NSTextViewExtension.h"#import "HorizontalGraphAxis.h"#import "VerticalGraphAxis.h"#import "ScientificView.h"#import "NSViewExtensions.h"#import	"MyCursor.h"#import "ZoomAnimation.h"#import "AppDelegate.h"#import "Random.h"#import	"myMath.h"#import "MyLog.h"@implementation ScientificViewconst  double                           SizeLimit = 20.0;                       // to accept window zoomconst  double                           RelativeSizeLimit = 0.3;                // to differentiate between horizontal, vertical and diagonal movesconst  int                              AutoTriggerFactor = 5;                  // number of cycles to wait before forcing trigger- (bool)compareWith:(double)value higherThan:(int)higher {    NSUserDefaults* defaults = NSUserDefaults.standardUserDefaults;    switch (higher) {        case -1:            return value < [defaults doubleForKey:@"triggerLevel"];        case 1:            return value > [defaults doubleForKey:@"triggerLevel"];        default:            NSAssert(false, @"Shouldnever ever happen");            return false;    }}- (void)clearSingleShot {    AppDelegate *appDelegate = (AppDelegate *)[[NSApplication sharedApplication] delegate];    [appDelegate clearSingleShot];}- (void) changeTriggerMode:(int) newTriggerMode {    _triggerMode = newTriggerMode;    _triggerState = WaitForLow;}- (void)checkAutoTrigger:(int *)autoTriggerCount {    switch (_triggerMode) {        case AutoTrigger:            *autoTriggerCount = *autoTriggerCount + 1;            if (*autoTriggerCount > AutoTriggerFactor*_scientificWidth) _triggerState = Triggered;            break;        default:            break;    }}- (void) readText:(NSString *)availableText  {        static int autoTriggerCount = 0;    // NSMutableString *lineString = [[NSMutableString alloc] initWithString:availableText];    // [lineString appendString:@"\n"];    // NSAttributedString *attrText = [[NSAttributedString alloc] initWithString:lineString];    //    // [scrollTextView appendToEnd:attrText];        NSArray* textArray = [availableText  componentsSeparatedByString:@"\t"];    NSString *triggerValueAsString = [textArray objectAtIndex:_triggerChannel];    double triggerValue = triggerValueAsString.doubleValue;    switch (_triggerState) {        case NoTrigger:            break;                    case WaitForLow:            NSLog(@"%d", _triggerPolarity);            if ([self compareWith:triggerValue+_triggerPolarity*10 higherThan:_triggerPolarity]) {                [self checkAutoTrigger:&autoTriggerCount];                break;            }            _triggerState = WaitForHigh;            // fall through        case WaitForHigh:            if ([self compareWith:triggerValue higherThan:-_triggerPolarity]) {                [self checkAutoTrigger:&autoTriggerCount];                break;            }            _triggerState = Triggered;            index = 0;            // fall through        default:                        for (int column = 0; column < MIN(textArray.count, 3); column++) {                threeArrays[column][index] = NSMakePoint(                                                index,                                                [[textArray objectAtIndex:column] intValue]                                             );            }            index ++;            if (index > _scientificWidth) {                index = 0;                autoTriggerCount = 0;                switch (_triggerMode) {                    case SingleTrigger:                        [self clearSingleShot];                        _triggerState = NoTrigger;                        break;                    default:                        _triggerState = WaitForLow;                        break;                }            }                        break;                }}/// Plot randomly some lines- (void) randomLines {    const int Count = 50;    NSPoint ptArray[Count];    for (int i = 0; i < Count; i++) {        ptArray[i] = NSMakePoint([Random value:self.frame.size.width],                                 [Random value:self.frame.size.height]                     );    }    NSBezierPath *path = [NSBezierPath bezierPath];    [path appendBezierPathWithPoints:ptArray count:Count];}/// Return version number- (char *) version {	static char sccsversion[] = "ScientificView 2021-05-16 "                                "copyright HJS from pslib.c 1.30 22.11.2003";	return sccsversion;}/// Support method to add bounds to tracking area/// @param newWindow Actual window to be added to tracking area- (void) viewWillMoveToWindow:(NSWindow *)newWindow {    // Setup a new tracking area when the view is added to the window.    NSTrackingArea* trackingArea =        [[NSTrackingArea alloc]            initWithRect:[self bounds]                 options:(NSTrackingMouseEnteredAndExited | NSTrackingActiveAlways)                   owner:self                userInfo:nil        ];    [self addTrackingArea:trackingArea];}/// Return YES as first responder- (BOOL) acceptsFirstResponder {	if (lastFirstResponder) {		return NO;	} else {		return YES;	}}/// Push mouse when entering the window/// @param theEvent Event when entering the window- (void) mouseEntered:(NSEvent *)theEvent {    [[myCursor getMyCursorFromState]  push];	lastFirstResponder = [[self window] firstResponder];		if([[self window] makeFirstResponder:self]) {		lastFirstResponder = [[self window] firstResponder];	} else {		lastFirstResponder = nil;	}}/// Pop mouse when exiting from the window/// @param theEvent Event when exiting the window- (void) mouseExited:(NSEvent *)theEvent {	if ([[self window] makeFirstResponder:lastFirstResponder]) {	}	lastFirstResponder = nil;    [NSCursor pop];}/// Act on mouse down/// @param event Mouse down event- (void) mouseDown:(NSEvent *)event {        NSLog(@"%ld %d", event.clickCount, myCursor.currentState);    mouseDownLocation = [self convertPoint:[event locationInWindow] fromView:nil];    mouseDownWindowRect = windowRect;    switch (myCursor.currentState) {        case HandState:            [myCursor setCursorToState:HandClosedState];            break;        case PlusState:            [self zoomInFromPoint:mouseDownLocation];            break;        case MinusState:            [self zoomOutFromPoint:mouseDownLocation];            break;        default:            break;    }    [self setNeedsDisplay:YES];    return;}/// Act on mouse drag move/// @param event Mouse drag event- (void) mouseDragged:(NSEvent *)event {    static NSPoint      lastMouseLoc;    int                 corner = 0;    NSPoint localPoint = [self convertPoint:[event locationInWindow] fromView:nil];        switch (myCursor.currentState) {                    case HandClosedState:                        [self panRect:mouseDownWindowRect                distanceX:mouseDownLocation.x - localPoint.x                distanceY:mouseDownLocation.y - localPoint.y            ];                       break;                     case ZoomState:        case ZoomTopLeftState:        case ZoomTopRightState:        case ZoomBottomLeftState:        case ZoomBottomRightState:        case LeftState:        case RightState:        case TopState:        case BottomState:            if (!NSEqualPoints(localPoint, lastMouseLoc)) {                NSRect newRubberbandRect =                    NSMakeRectFromPoints(mouseDownLocation, localPoint);                                if (   newRubberbandRect.size.width < SizeLimit                    && newRubberbandRect.size.height >= SizeLimit                    ) {                    if (mouseDownLocation.y - localPoint.y > 0) {                        [myCursor setCursorToState:BottomState];                    }                    else {                        [myCursor setCursorToState:TopState];                    }                    rubberbandRect = NSMakeRect(self.bounds.origin.x,                                                newRubberbandRect.origin.y,                                                self.bounds.size.width,                                                newRubberbandRect.size.height                                     );                }                else if (   newRubberbandRect.size.height < SizeLimit                         && newRubberbandRect.size.width >= SizeLimit                    ) {                    if (mouseDownLocation.x - localPoint.x > 0) {                        [myCursor setCursorToState:LeftState];                    }                    else {                        [myCursor setCursorToState:RightState];                    }                    rubberbandRect = NSMakeRect(newRubberbandRect.origin.x,                                                self.bounds.origin.y,                                                newRubberbandRect.size.width,                                                self.bounds.size.height                                     );                } else if (   newRubberbandRect.size.width  >= SizeLimit                           && newRubberbandRect.size.height >= SizeLimit) {                    if (mouseDownLocation.x>localPoint.x) corner += 1;                    if (mouseDownLocation.y>localPoint.y) corner += 2;                    [myCursor setCursorToState:ZoomTopRightState+corner];                    rubberbandRect = newRubberbandRect;                } else {                    rubberbandRect = NSZeroRect;                }                [self setNeedsDisplay: YES];            }            break;        default:            break;    }    lastMouseLoc = localPoint;}/// Act on mouse up/// @param event Mouse up event- (void) mouseUp:(NSEvent *)event {        NSLog(@"%ld", event.clickCount);    switch (event.type) {        case NSEventTypeLeftMouseUp:            switch (myCursor.currentState) {                case HandClosedState:                    [myCursor setCursorToState:HandState];                    break;                case ZoomTopLeftState:                case ZoomTopRightState:                case ZoomBottomLeftState:                case ZoomBottomRightState:                case LeftState:                case RightState:                case TopState:                case BottomState:                    if ((rubberbandRect.size.width  > SizeLimit) &&                        (rubberbandRect.size.height > SizeLimit))                    {                        [animate startAnimation];                    }                    rubberbandRect = NSZeroRect;                    [myCursor setCursorToState:ZoomState];                    break;                case PlusState:                default:                    break;            }            break;        default:            break;    }}/// Magnify event/// @param event Magnify event- (void) magnifyWithEvent:(NSEvent *)event {    switch (event.phase) {        case NSEventPhaseBegan:            switch (magnificationMode) {                case Magnify:                    [MyCursor.magnifyCursor push];                    break;                case Vertical:                    [MyCursor.resizeUpDownCursor push];                    break;                case Horizontal:                    [MyCursor.resizeLeftRightCursor push];                    break;                default:                    break;            }            break;        case NSEventPhaseEnded:            [MyCursor pop];            break;        case NSEventPhaseCancelled:            [MyCursor pop];            break;        case NSEventPhaseChanged: {            NSPoint localPoint = [self convertPoint:event.locationInWindow                                           fromView:nil];            switch (magnificationMode) {                case Magnify:                    [self zoomInToRect:                        [self zoomFromPoint:localPoint                                   magnifyX:1/(1+event.magnification)                                   magnifyY:1/(1+event.magnification)                        ]                    ];                    break;                                    case Vertical:                    [self zoomInToRect:                        [self zoomFromPoint:localPoint                                   magnifyX:1                                   magnifyY:1/(1+event.magnification)                        ]                    ];                    break;                case Horizontal:                    [self zoomInToRect:                        [self zoomFromPoint:localPoint                                   magnifyX:1/(1+event.magnification)                                   magnifyY:1                        ]                    ];                    break;                default:                    break;            }            }            break;        default:            break;    }}- (void) moveCursor:(NSEvent * _Nonnull)event {    CGEventRef cgEvent = CGEventCreate(nil);    CGPoint loc = CGEventGetLocation(cgEvent);    CGWarpMouseCursorPosition(        NSMakePoint(loc.x+event.scrollingDeltaX , loc.y+event.scrollingDeltaY)    );}/// Two finger hover event/// @param event Hover event- (void) scrollWheel:(NSEvent *)event {    switch (event.phase) {        case NSEventPhaseBegan:            [myCursor setCursorToState:HandClosedState];            break;        case NSEventPhaseEnded:        case NSEventPhaseCancelled:            [myCursor setCursorToState:HandState];            break;        case NSEventPhaseChanged:                [self panRect:windowRect distanceX:-event.scrollingDeltaX                                         distanceY: event.scrollingDeltaY                ];                // Also move cursor position                [self moveCursor:event];                    break;        default:            break;    }}/// Execute a swipe gesture./// @param event Swipe event- (void) swipeWithEvent:(NSEvent *)event {    NSLog(@"");}- (void) setMagnificationMode:(NSArray<NSTouch*> *) points {    NSPoint first  = points[0].normalizedPosition;    NSPoint second = points[1].normalizedPosition;        if (   fabs(first.x-second.x) < RelativeSizeLimit        && fabs(first.y-second.y) < RelativeSizeLimit) {        magnificationMode = None;    }    else if (fabs(first.x-second.x) < RelativeSizeLimit) {        magnificationMode = Vertical;    }    else if (fabs(first.y-second.y) < RelativeSizeLimit) {        magnificationMode = Horizontal;    }    else {        magnificationMode = Magnify;    }}- (void) touchesBeganWithEvent:(NSEvent *)event {    NSSet<NSTouch *> *touches = [event touchesForView:self];    switch (touches.count) {        case 2:            [self setMagnificationMode:touches.allObjects];            break;        default:            break;    }}- (void) touchesMovedWithEvent:(NSEvent *)event {    //NSLog(@"%d", [event touchesForView:self].count);    //for (int i = 0; i < [event allTouches].count; i++) {    //    NSLog(@"%d", i);    //    //[self allTouches].;    //}}- (void) touchesEndedWithEvent:(NSEvent *)event {    //NSLog(@"%d", [event touchesForView:self].count);    //for (int i = 0; i < [event allTouches].count; i++) {    //    NSLog(@"%d", i);    //    //[self allTouches].;    //}}- (void) touchesCancelledWithEvent:(NSEvent *)event {}/*- (void) pressureChangeWithEvent:(NSEvent *)event {    NSLog(@"");}- (void) swipeWithEvent:(NSEvent *)event {    NSLog(@"");}- (void)beginGestureWithEvent:(NSEvent *)event {    NSLog(@"Gesture detected!");}- (void)endGestureWithEvent:(NSEvent *)event {    NSLog(@"Gesture end detected!");}- (void)rotateWithEvent:(NSEvent *)event {    NSLog(@"Informs the receiver that the user has begun a rotation gesture.");}- (void)touchesBeganWithEvent:(NSEvent *)event {    NSLog(@"Informs the receiver that new set of touches has been "        "recognized.");}- (void) touchesMovedWithEvent:(NSEvent *)event {    NSLog(@"Informs the receiver that one or more touches has moved.");}- (void) touchesCancelledWithEvent:(NSEvent *)event {    NSLog(@"Informs the receiver that tracking of touches has been "            "cancelled for any reason.");}- (void) touchesEndedWithEvent:(NSEvent *)event {    NSLog(@"Returns that a set of touches have been removed.");}- (BOOL) wantsForwardedScrollEventsForAxis:(NSEventGestureAxis)axis {    NSLog(@"Returns whether to forward elastic scrolling gesture "            "events up the responder.");    return false;}- (void) smartMagnifyWithEvent:(NSEvent *)event {    NSLog(@"Informs the receiver that the user performed a smart "        "zoom gesture.");}      - (BOOL) wantsScrollEventsForSwipeTrackingOnAxis:(NSEventGestureAxis)axis {    NSLog(@"wantsScrollEventsForSwipeTrackingOnAxis");    return false;}*//// Not transparent view contents- (BOOL) isOpaque {    return YES;                                                                 // indicates complete view is covered, no event send to background}/// Set frame rectangle/// @param frameRect New frame rect- (void) setFrame:(NSRect)frameRect {    [super setFrame:frameRect];    rubberbandRect.size.height = [self bounds].size.height;                     // for the missused rubberbandRect}/// Check keyboard modifiers/// @param theEvent Keyboard event- (void) flagsChanged:(NSEvent *)theEvent {    if ([theEvent modifierFlags] & NSEventModifierFlagShift) {        [myCursor setCursorToState:MinusState];    } else if ([theEvent modifierFlags] & NSEventModifierFlagOption) {        [myCursor setCursorToState:HandState];    } else {        [myCursor setCursorToState:PlusState];    }}/// Execute a zoom in/// @param sender Sender description- (IBAction) zoomIn:(id)sender {    rubberbandRect = NSMakeRect(                           0.05*self.bounds.size.width                        ,  0.05*self.bounds.size.height                        ,  0.90*self.bounds.size.width                        ,  0.90*self.bounds.size.height                     );    [animate startAnimation];}/// Execute a zoom out/// @param sender Sender description- (IBAction) zoomOut:(id)sender {    rubberbandRect = NSMakeRect(                           -0.05*self.bounds.size.width                        ,  -0.05*self.bounds.size.height                        ,   1.10*self.bounds.size.width                        ,   1.10*self.bounds.size.height                     );    [animate startAnimation];}/// Zoom from point with magnification/// @param mouseLoc Central point for the magnification/// @param magnifyX Magnification factor/// @param magnifyY Magnification factor- (NSRect) zoomFromPoint:(NSPoint)mouseLoc magnifyX:(double)magnifyX                                           magnifyY:(double)magnifyY {    NSSize  size = NSMakeSize(magnifyX*self.bounds.size.width                            , magnifyY*self.bounds.size.height                   );    return NSMakeRect(                           (1-magnifyX)*mouseLoc.x                        ,  (1-magnifyY)*mouseLoc.y                        ,  size.width                        ,  size.height                     );}/// Zoom in from point with factor 2/// @param mouseLoc Zoom Center location- (void) zoomInFromPoint:(NSPoint)mouseLoc {    rubberbandRect = [self zoomFromPoint:mouseLoc magnifyX:0.5 magnifyY:0.5];    [animate startAnimation];}/// Zoom out from point with factor 2/// @param mouseLoc Zoom Center location- (void)	zoomOutFromPoint:(NSPoint)mouseLoc {    rubberbandRect = [self zoomFromPoint:mouseLoc magnifyX:2 magnifyY:2];    [animate startAnimation];}/// Zoom to rect mouse rectangle/// @param mouseRect New destination rectangle- (void) zoomInToRect:(NSRect)mouseRect {    zoomOffset = _offset;    zoomScale  = _scale;    [self zoomInToRectFixed:mouseRect];}/// Internal zoom to rectangle used for animation/// @param mouseRect New destination rectangle- (void) zoomInToRectFixed:(NSRect)mouseRect {    NSPoint diff = NSSubtractPoints(mouseRect.origin, zoomOffset);    NSRect myRect = NSMakeRect(                  diff.x                 /zoomScale.x               ,  diff.y                 /zoomScale.y               ,  mouseRect.size.width   /zoomScale.x               ,  mouseRect.size.height  /zoomScale.y           );        windowRect = NSMakeRect(myRect.origin.x, myRect.origin.y,                            myRect.size.width, myRect.size.height                 );    [self secondaryFromX:myRect.origin.x                     ToX:myRect.origin.x+myRect.size.width    ];    [self setNeedsDisplay: YES];}/// Alternative to before/// @param mouseRect New destination rectangle- (void) zoomInToRectFixed2:(NSRect)mouseRect {    double xScale  =  self.bounds.size.width /mouseRect.size.width;    double xOffset = (self.bounds.origin.x -  mouseRect.origin.x) * xScale;    double yScale  =  self.bounds.size.height/mouseRect.size.height;    double yOffset = (self.bounds.origin.y -  mouseRect.origin.y) * yScale;    NSRect myRect = NSMakeRect(                 (mouseRect.origin.x-xOffset)/xScale               , (mouseRect.origin.y-yOffset)/yScale               ,  mouseRect.size.width       /xScale               ,  mouseRect.size.height      /yScale           );        windowRect = NSMakeRect(myRect.origin.x,   myRect.origin.y,                            myRect.size.width, myRect.size.height                 );    [self secondaryFromX:myRect.origin.x                     ToX:myRect.origin.x+myRect.size.width    ];    [self setNeedsDisplay: YES];}/// Pan for drag mouse reaction/// @param sourceRect Original rectangle/// @param dx Pan x distance/// @param dy Pan y distance- (void) panRect:(NSRect)sourceRect distanceX:(double)dx distanceY:(double)dy {    /*     Developers of OpenGL applications should not rely on the rectangle in     this property to convert coordinates to pixels automatically in future     releases. Instead, you should convert coordinates to device space     explicitly using the convertPointToBase:, convertSizeToBase:, or     convertRectToBase: methods or their earlier counterparts     convertPoint:toView:, convertSize:toView:, or convertRect:toView:.     */    //NSLog(@"%f %f", 1/offsetScale.xScale, sourceRect.size.width /self.bounds.size.width);    windowRect = NSOffsetRect(sourceRect                            , sourceRect.size.width /self.bounds.size.width *dx                            , sourceRect.size.height/self.bounds.size.height*dy                              );    [self setNeedsDisplay: YES];}/// see above, for a secondary scale in the same view/// output:///     -/// globals:///     ...///example:///    [self secondaryFromX:0.0 ToX:3.1415 AndFromY:-1.0 ToY:1.0];/// @param xmin Minimum X/// @param xmax Maximum X/// @param ymin Minimum Y/// @param ymax Maximum Y- (void) secondaryFromX:(double)xmin ToX:(double)xmax               AndFromY:(double)ymin ToY:(double)ymax{	secondaryRect.size.width	= xmax-xmin;	secondaryRect.size.height	= ymax-ymin;	secondaryRect.origin		= NSMakePoint(xmin, ymin);}/// see above, but keeps the y scale/// output:///     -/// globals:///     .../// example:///    [self secondaryFromX:0.0 ToX:3.1415];/// @param xmin Minimum X/// @param xmax Maximum X- (void) secondaryFromX:(double)xmin ToX:(double)xmax {	secondaryRect.size.width	= xmax-xmin;	secondaryRect.origin.x		= xmin;}/// Choose primary coordinates for scaling- (void) choosePrimary {	currentRect = &windowRect;	[self calcScaling];}/// Choose secondary coordinates for scaling- (void) chooseSecondary {	currentRect = &secondaryRect;	[self calcScaling];}/// Calculate scaling for current rectangle- (void) calcScaling {    _scale.x  =  self.bounds.size.width /currentRect->size.width;    _offset.x = (self.bounds.origin.x - currentRect->origin.x) * _scale.x;    _scale.y  =  self.bounds.size.height/currentRect->size.height;    _offset.y = (self.bounds.origin.y - currentRect->origin.y) * _scale.y;}/// Getter for the minimum x- (double) minX {															    //! returns minimum x-value	return currentRect->origin.x;}/// Getter for the maximum x- (double) maxX {															    //! returns maximum x-value	return currentRect->origin.x+currentRect->size.width;}/// Getter for the primary window- (NSRect) windowRect {													        //! first window in user coordinates	return windowRect;}/// Getter for the secondary window- (NSRect) secondaryRect {													    //! secondary window in user coordinates	return secondaryRect;}/// Set primary window/// @param newRect New primary window- (void) setWindowRect:(NSRect)newRect {									    //! first window in user coordinates	windowRect = newRect;    [self choosePrimary];}/// Set secondary window/// @param newRect New secondary window- (void) setSecondaryRect:(NSRect)newRect {								        //! secondary window in user coordinates	secondaryRect = newRect;    [self chooseSecondary];}/// penup disables the drawing with plot, resp. plotto. This cammand is used/// to start a new chain of line segments./// input:///         -/// output:///         -- (void) penup {	penIsDown = false;}/// pendown enables the drawing with plot, resp. plotto. Usually this/// command is not used./// input:///     -/// output:///     -- (void)	pendown {	penIsDown = true;}/// linewidth defines a new line thickness. The parameter is given in global/// units. A hairline is achieved, when 0.0 is passed as width value./// input:///     width:            linewidth in global units./// output:///    -/// @param width Width of the line- (void) setLineWidth:(double)width {    double lineWidth =                        width;//                      ///                    --------------------------------------------------//                        sqrt(transformStruct.m11*transformStruct.m11//                           + transformStruct.m22*transformStruct.m22);	[NSBezierPath setDefaultLineWidth:lineWidth];}#define USE_SCALE#ifdef USE_SCALE/// move perfoms a relative move. No drawing is performed. Only the current/// position is changed./// input:///     @param dx Relative x displacement of the pen.///     @param dy Relative y displacement of the pen./// output:///     -- (void) move:(double)dx :(double)dy {                                          // move relative    cursorPosition.x += dx*_scale.x;    cursorPosition.y += dy*_scale.y;}////// moveto displaces the pen in absolute units. No drawing is performed./// input:///     @param x Absolute x coordinate///     @param y Absolute y coordinate/// output:///     -/// Offset added by transform before drawing!- (void)    moveto:(double)x :(double)y {                                      // move absolute        cursorPosition.x = x*_scale.x;//+_offset.x;    cursorPosition.y = y*_scale.y;//+_offset.y;}/// draw produces a line with relative coordinates. Drawing is performed/// using the current dash pattern and color./// input:///     @param dx Relative x coordinate///     @param dy Relative y coordinate/// output:///     -- (void) draw:(double)dx :(double)dy {                                         //! draw relative    NSPoint    newPoint;        newPoint = NSMakePoint(cursorPosition.x+dx*_scale.x,                           cursorPosition.y+dy*_scale.y                           );    [NSBezierPath strokeLineFromPoint:cursorPosition toPoint:newPoint];    cursorPosition = newPoint;}/// drawto draws a line absolutely. Drawing is performed using the/// current dash pattern and color./// input:///     @param x Absolute x position///     @param y Absolute y position/// output:///    -/// Offset added by transform before drawing!- (void) drawto:(double)x :(double)y {                                        //! draw absolute    NSPoint    newPoint;        newPoint = NSMakePoint(x*_scale.x, y*_scale.y);    [NSBezierPath strokeLineFromPoint:cursorPosition toPoint:newPoint];    cursorPosition = newPoint;}#else/// move perfoms a relative move. No drawing is performed. Only the current/// position is changed./// input:///     @param dx Relative x displacement of the pen.///     @param dy Relative y displacement of the pen./// output:///     -- (void) move:(double)dx :(double)dy {									        // move relative	cursorPosition.x += dx;	cursorPosition.y += dy;}////// moveto displaces the pen in absolute units. No drawing is performed./// input:///     @param x Absolute x coordinate///     @param y Absolute y coordinate/// output:///     -- (void)	moveto:(double)x :(double)y {									    // move absolute	cursorPosition.x = x;	cursorPosition.y = y;}/// draw produces a line with relative coordinates. Drawing is performed/// using the current dash pattern and color./// input:///     @param dx Relative x coordinate///     @param dy Relative y coordinate/// output:///     -- (void) draw:(double)dx :(double)dy {										    //! draw relative	NSPoint	newPoint;	newPoint = NSMakePoint(cursorPosition.x+dx, cursorPosition.y+dy);	[NSBezierPath strokeLineFromPoint:cursorPosition toPoint:newPoint];	cursorPosition = newPoint;}/// drawto draws a line absolutely. Drawing is performed using the/// current dash pattern and color./// input:///     @param x Absolute x position///     @param y Absolute y position/// output:///    -- (void) drawto:(double)x :(double)y {										    //! draw absolute	NSPoint	newPoint;	newPoint = NSMakePoint(x, y);	[NSBezierPath strokeLineFromPoint:cursorPosition toPoint:newPoint];	cursorPosition = newPoint;}#endif/// plot appends a line segment to the current line using relative move./// If penup() was called directly before, than no drawing will be/// performed. This command enables drawing of a curve out of serveral/// line segments in one single for(;;) loop./// input:///     @param dx Relative x coordinate///     @param dy Relative y coordinate- (void) plot:(double)dx :(double)dy {										    // plot relative	if (penIsDown) {		[self draw:dx :dy];	} else {		[self move:dx :dy];		[self pendown];	}} /// plot appends a line segment to the current line using absolute move./// If penup() was called directly before, than no drawing will be/// performed. This command enables drawing of a curve out of serveral/// line segments in one single for(;;) loop./// input:///     @param x Absolute x position///     @param y Absolute y position///     globals:        pen_is_down/// output:///     globals:        pen_is_down set to true- (void) plotto:(double)x :(double)y {										    // plot absolute	if (penIsDown) {		[self drawto:x :y];	} else {		[self moveto:x :y];		[self pendown];	}}/// Setter for the color/// @param newColor New color- (void) setColor:(NSColor *)newColor {									        // set color for following outputs	[newColor set];															    // set forground color	[attrs setObject:newColor forKey:NSForegroundColorAttributeName];		    // set and add new text color to dictionary}/// Draw text/// @param markString The text to be used as marking/// @param textAlignment Alignment for the text- (void) drawString:(NSString *)markString          alignment:(TextPosition)textAlignment {	NSSize				size;	NSPoint				textPosition= cursorPosition;    const double        RelativeTextMargin = 0.2;                               // Shift a bit more from the axis		size = [markString sizeWithAttributes:attrs];	switch (textAlignment) {		case 	TopLeft:		case 	Left:		case 	BottomLeft:                textPosition.x -= size.width*(1+RelativeTextMargin);                break;		case 	TopCenter:		case 	Center:		case 	BottomCenter:                textPosition.x -= size.width/2;                break;		default:                textPosition.x += size.width*RelativeTextMargin;                break;	}	switch (textAlignment) {		case 	Left:		case 	Center:		case 	Right:                textPosition.y -= size.height/2;                break;		case 	BottomLeft:		case 	BottomCenter:		case 	BottomRight:                textPosition.y -= size.height*(1+RelativeTextMargin);                break;		default:                textPosition.x += size.width*RelativeTextMargin;                break;	}	[markString drawAtPoint:textPosition withAttributes:attrs];    //[markString drawInRect:NSMakeRect(textPosition.x, textPosition.y, 100/offsetScale.xScale, 100/offsetScale.yScale) withAttributes:attrs];}/// Setter for the symbol size/// @param newSymbolSize New symbol size- (void) setSymbolSize:(int)newSymbolSize {	symbolSize = newSymbolSize;}/// Draw a centered symbol/// @param symbolCode The symbol to be printed- (void) drawCenteredSymbol:(int)symbolCode {	NSRect		enclosingRect;		enclosingRect  = NSMakeRect(cursorPosition.x-symbolSize/2,                                cursorPosition.y-symbolSize/2,                                symbolSize,                                symbolSize                     );	switch (symbolCode) {		case 0:			[[NSBezierPath bezierPathWithOvalInRect:enclosingRect] fill];			break;		case 1:			[[NSBezierPath bezierPathWithOvalInRect:enclosingRect] stroke];			break;		default: {				double			size = 20.0;				NSPoint			myPoint;				NSFont			*fontObj;				NSRect			bounds;				NSBezierPath	*myPath;								myPath = [NSBezierPath bezierPath];				fontObj = [NSFont fontWithName:@"Zapf Dingbats" size:size];				bounds = [fontObj boundingRectForGlyph:symbolCode];				myPoint = NSMakePoint(cursorPosition.x-bounds.size.width/2,                                      cursorPosition.y-bounds.size.height/2                          );				[myPath moveToPoint:myPoint];				//[myPath appendBezierPathWithGlyph:symbolCode inFont:fontObj];                [myPath appendBezierPathWithCGGlyph:symbolCode inFont:fontObj];								[myPath stroke];			}			break;	}}/// Plot a circle with backing radius 20/// @param point Center of the circle- (void) plotCircleAt:(NSPoint) point {    [self plotCircleAt:point radius:20];}/// Plot a circle with backing radius radius/// @param point Center of the circle/// @param radius Radius of the circle- (void) plotCircleAt:(NSPoint) point radius:(double) radius {    NSRect    dotRect = NSMakeRect(                            point.x*_scale.x - radius,                            point.y*_scale.y - radius,                            2 * radius,                            2 * radius                        );        NSBezierPath *path = [NSBezierPath bezierPath];    [path appendBezierPathWithOvalInRect: dotRect];    [path fill];}/// Plot sine/// @param frequency Frequency for the sine/// @param amplitude Amplitude of the sine/// @param phase Phase for the sine- (void) plotSine:(double)frequency amplitude:(double)amplitude                                        phase:(double)phase{    [self penup];    const double s = windowRect.size.width/self.bounds.size.width;    NSBezierPath *path = [NSBezierPath bezierPath];    double x = windowRect.origin.x;    [path       moveToPoint:NSMakePoint(x*_scale.x,        amplitude*sinf(phase+x*frequency)*_scale.y)];    for (; x < windowRect.origin.x + windowRect.size.width; x += s) {        [path     lineToPoint:NSMakePoint(x*_scale.x,          amplitude*sinf(phase+x*frequency)*_scale.y)];    }    [path setLineWidth:0.0];    [path stroke];}/// Append text to scroll view/// @param text Text to be appended- (void) appendText:(NSString *)text {    NSAttributedString *attrText = [[NSAttributedString alloc] initWithString:text];                                               [scrollTextView.textStorage appendAttributedString:attrText];}/// Append line with text to scroll view/// @param text Text to be appended with <cr>- (void) appendLine:(NSString *) text {    NSMutableString *lineString = [[NSMutableString alloc] initWithString:text];    [lineString appendString:@"\n"];    [self appendText:lineString];            NSPoint newScrollOrigin;        // assume that the scrollview is an existing variable    if ([[scrollView documentView] isFlipped]) {        newScrollOrigin=NSMakePoint(0.0, NSMaxY([[scrollView documentView] frame])                                        -NSHeight([[scrollView contentView] bounds]));    } else {        newScrollOrigin=NSMakePoint(0.0,0.0);    }        [[scrollView documentView] scrollPoint:newScrollOrigin];}/// Graphics contents animation/// @param timer Timer for the timer event- (void) animateContents:(NSTimer *)timer {    sinePhase += 0.1;    [self setNeedsDisplay:YES];}//  Routine called before class instance is being displayed//  The original sample code was using a bool variable initialized to//  avoid the contents to be initialized multiple times. This has to be//  removed, since this class serves as virtual super class and needs//  to be initialized for every instance.            11.10.2005    HJS- (void) awakeFromNib {    NSColor               *color;    NSFont                *font;        _scientificWidth    =  499.0;    _scientificHeight   = 2048.0;    _widthMargin        =    0.1;    _heightMargin       =    0.1;    sinePhase           =    0.0;        trackingTag = [self addTrackingRect:[self bounds]                                  owner:self                               userData:nil                           assumeInside:NO                  ];                rubberbandRect = NSZeroRect;    [self choosePrimary];        font  = [NSFont systemFontOfSize:12];    color = [NSColor blueColor];    attrs = [NSMutableDictionary dictionaryWithCapacity:2];    [attrs setObject:font  forKey:NSFontAttributeName];    [attrs setObject:color forKey:NSForegroundColorAttributeName];    [self setSymbolSize:6];        redPoint.x = 0;    redPoint.y = 0;        greenPoint.x = 100.0;    greenPoint.y =   0.0;        yellowPoint.x = 100.0;    yellowPoint.y = 100.0;        [self setHome];    horizontalAxis = [[HorizontalGraphAxis alloc] initWithScientificView:self];    verticalAxis   = [[VerticalGraphAxis alloc]   initWithScientificView:self];        myCursor = [[MyCursor alloc]                initWithState:(CursorState)_modeSelector.indexOfSelectedItem                ];    animate = [[ZoomAnimation alloc] initWithDuration:0.5                                       animationCurve:NSAnimationEaseIn               ];    [animate setAnimationBlockingMode:NSAnimationNonblocking];    [animate setDelegate:self];            [NSTimer scheduledTimerWithTimeInterval:0.03                                     target:self                                   selector:@selector(animateContents:)                                   userInfo:nil                                    repeats:YES     ];        //[self setWantsRestingTouches:YES];    self.allowedTouchTypes = NSTouchTypeMaskIndirect;                           // replaces self.acceptsTouchEvents = YES;        threePathes[0] = [NSBezierPath bezierPath];    threePathes[1] = [NSBezierPath bezierPath];    threePathes[2] = [NSBezierPath bezierPath];       index = 0;    for (int column = 0; column < 3; column++) {        threeArrays[column] = calloc(MaxSamples, sizeof(NSPoint));    }    _triggerState = WaitForLow;    _triggerChannel = 0;            }-(void)dealloc {    //cleanup code    for (int column = 0; column < 3; column++) {        free (threeArrays[column]);    }}/// Used as paint event/// @param rect Rectangle for the contents- (void) drawRect:(NSRect)rect {    NSArray *colors = @[ [NSColor redColor]                       , [NSColor greenColor]                       , [NSColor blueColor]                    ];        NSEraseRect(self.bounds);        if (self.bounds.origin.x != 0 || self.bounds.origin.y != 0) {        NSAssert(false, @"Here we have an issue");    }    NSAffineTransform* xform = [NSAffineTransform transform];        [xform translateXBy:_offset.x yBy:_offset.y];    // No scaling to avoid impact on lineWidth    //[xform scaleXBy:_offsetScale.scale.x yBy:_offsetScale.scale.y];    [xform concat];    [self choosePrimary];        [horizontalAxis setGridRect:windowRect];    [verticalAxis   setGridRect:windowRect];    [self setColor:[NSColor grayColor]];        [verticalAxis lineAt: 0.0];    [verticalAxis linTics:0.0  separation:0.0 ticPercent:0.7            andMajorEvery:10   lineWidth:0.5     ];    [verticalAxis linAnnotation:0.0 separation:0.0 alignment:Left];        [horizontalAxis lineAt: 0.0];    [horizontalAxis linTics:0.0  separation:0.0 ticPercent:0.7              andMajorEvery:10   lineWidth:0.5     ];    [horizontalAxis linAnnotation:0.0 separation:0.0 alignment:Bottom];        [self setColor:[NSColor blueColor]];    [self plotCircleAt:mouseDownLocation radius:5];        [self setColor:[NSColor redColor]];    [self plotCircleAt:redPoint radius:5];        for (int column = 0; column < 3; column++) {                [self setColor:[colors objectAtIndex:column]];        NSBezierPath *path = [NSBezierPath bezierPath];                [path moveToPoint:               NSMakePoint(threeArrays[column][0].x*_scale.x,                           threeArrays[column][0].y*_scale.y)];                for (int i = 1; i < _scientificWidth; i++) {            [path lineToPoint:               NSMakePoint(threeArrays[column][i].x*_scale.x,                           threeArrays[column][i].y*_scale.y)];        }        [path setLineWidth:1.0];        [path stroke];    }    /*    NSLog(@"%f %f %f %f %f %f", xform.transformStruct.m11          , xform.transformStruct.m12          , xform.transformStruct.m21          , xform.transformStruct.m22          , xform.transformStruct.tX          , xform.transformStruct.tY);    */        //[self setColor:[NSColor greenColor]];    //[self plotSine:0.05 amplitude:500.0 phase:sinePhase];        [self setColor:[NSColor blueColor]];    [threePathes[1] stroke];        [self setColor:[NSColor greenColor]];    [self plotCircleAt:greenPoint radius:5];    [threePathes[2] stroke];        [self setColor:[NSColor yellowColor]];    [self plotCircleAt:yellowPoint radius:5];        [xform invert];    [xform concat];            [self setColor:[NSColor blueColor]];    [[NSBezierPath bezierPathWithRect:rubberbandRect] stroke];}/// Animation support/// @param animation Animation instance- (BOOL) animationShouldStart:(NSAnimation *)animation {    [self choosePrimary];    zoomOffset = _offset;    zoomScale  = _scale;    sourceRect = self.bounds;    destinationRect = rubberbandRect;    rubberbandRect = NSZeroRect;    return TRUE;}/// Delate routine for the animation/// @param value Timing value 0.0...1.0- (void) doAnimation:(double) value {        NSRect zoomRect = NSMakeZoomedRectFrom(value, destinationRect, sourceRect);    [self zoomInToRectFixed:zoomRect];}- (IBAction) setHome:(NSButton *)sender {    [self setHome];}- (void) setHome {    homeRect = NSMakeRect(        -_scientificWidth  * _widthMargin,        -_scientificHeight * _heightMargin,        _scientificWidth   * (1 + 2*_widthMargin),        _scientificHeight  * (1 + 2*_heightMargin)    );    windowRect = homeRect;        [self choosePrimary];    [self setNeedsDisplay:YES];}- (void) animateHome {    rubberbandRect = NSMakeRect(            (homeRect.origin.x - windowRect.origin.x)     ///        ---------------------------------------------          windowRect.size.width *self.bounds.size.width                                        ,   (homeRect.origin.y - windowRect.origin.y)     ///        ---------------------------------------------          windowRect.size.height*self.bounds.size.height                                        , self.bounds.size.width  * homeRect.size.width   ///        ---------------------------------------------                    windowRect.size.width                                        , self.bounds.size.height * homeRect.size.height  ///        ----------------------------------------------                    windowRect.size.height    );            [animate startAnimation];}- (void) updateTrackingAreas {    [self removeTrackingRect:trackingTag];        trackingTag = [self addTrackingRect:[self bounds]                    owner:self                 userData:nil             assumeInside:NO    ];    [super updateTrackingAreas];}- (IBAction)setSelect:(NSButton *)sender {    myCursor.currentState = ZoomTopLeftState;}- (IBAction)clickGesture:(NSClickGestureRecognizer *)sender {    NSLog(@"clickGesture");}- (IBAction)doubleClickGesture:(NSClickGestureRecognizer *)sender {    switch (sender.state) {        case NSGestureRecognizerStateBegan:            break;        case NSGestureRecognizerStateChanged:            break;        case NSGestureRecognizerStateEnded:            [self animateHome];            break;        default:            break;    }}- (IBAction) maginfyingGesture:(NSMagnificationGestureRecognizer *)sender {    //NSPoint magnificationDownLocation = mouseDownLocation;    NSLog(@"%f %f %f", sender.magnification,            [sender locationInView:self].x, [sender locationInView:self].y    );    switch (sender.state) {        case NSGestureRecognizerStateBegan:            break;        case NSGestureRecognizerStateChanged:            break;        case NSGestureRecognizerStateEnded:            break;        default:            break;    }}- (IBAction) panGesture:(NSPanGestureRecognizer *)sender {    NSLog(@"panGesture");}- (IBAction) pressGesture:(NSPressGestureRecognizer *)sender {    NSLog(@"pressGesture");}- (IBAction) rotationGesture:(NSRotationGestureRecognizer *)sender {    NSLog(@"rotationGesture");}- (IBAction) gestureRecognizer:(NSGestureRecognizer *)sender {    NSLog(@"gestureRecognizer");}- (IBAction) changeMode:(NSSegmentedControl *)sender {    [myCursor setCursorToState:(CursorState)sender.indexOfSelectedItem];}- (IBAction)slider0:(NSSlider *)sender {    NSLog(@"0: %f", sender.doubleValue);}- (IBAction)slider1:(NSSlider *)sender {    NSLog(@"1: %f", sender.doubleValue);}- (IBAction)slider2:(NSSlider *)sender {    NSLog(@"2: %f", sender.doubleValue);}/*- (IBAction)clickGesture:(NSClickGestureRecognizer *)sender {    NSLog(@"clickGesture");    mouseDownLocation = [sender locationInView:self];    NSLog(@"%f %f", mouseDownLocation.x, mouseDownLocation.y);    }- (IBAction)maginficationGesture:(NSMagnificationGestureRecognizer *)sender {    NSLog(@"maginficationGesture");    //static NSPoint magnificationDownLocation = mouseDownLocation;    switch (sender.state) {        case NSGestureRecognizerStateBegan:            [self appendLine:[NSString stringWithFormat:@"Began   %f %f", mouseDownLocation.x, mouseDownLocation.y]];            offset = mouseDownLocation;            break;        case NSGestureRecognizerStateChanged:            [self appendLine:[NSString stringWithFormat:@"Changed %f %f %f", mouseDownLocation.x, mouseDownLocation.y, sender.magnification]];                        if (fabs([sender locationInView:self].x-magnificationDownLocation.x) < SizeLimit) {                [self zoomInToRect2:NSMakeRect(                          self.bounds.origin.x                        , self.bounds.origin.y + self.bounds.size.height*sender.magnification                        , self.bounds.size.width                        , self.bounds.size.height*(1+sender.magnification)                      )                ];            }            else if (fabs([sender locationInView:self].y-magnificationDownLocation.y) < SizeLimit) {                [self zoomInToRect2:NSMakeRect(                          self.bounds.origin.x + self.bounds.size.width*sender.magnification                        , self.bounds.origin.y                        , self.bounds.size.width*(1+sender.magnification)                        , self.bounds.size.height                      )                ];            } else {                           [self zoomInToRect2:NSMakeRect(                         self.bounds.origin.x - 0.5*self.bounds.size.width *(1+sender.magnification)                       , self.bounds.origin.y - 0.5*self.bounds.size.height*(1+sender.magnification)                       , self.bounds.size.width *(1+sender.magnification)                       , self.bounds.size.height*(1+sender.magnification)                     )                ];            }            break;        case NSGestureRecognizerStateEnded:            [self appendLine:[NSString stringWithFormat:@"Ended  %f %f", mouseDownLocation.x, mouseDownLocation.y]];            break;        default:            [self appendLine:[NSString stringWithFormat:@"%ld   %f %f", sender.state, mouseDownLocation.x, mouseDownLocation.y]];            break;    }} - (IBAction)panGesture:(NSPanGestureRecognizer *)sender {    static NSPoint panDownLocation;    switch (sender.state) {        case NSGestureRecognizerStateBegan:            panDownLocation = [sender locationInView:self];            NSLog(@"Began   %f %f", panDownLocation.x, panDownLocation.y);            break;        case NSGestureRecognizerStateChanged:            NSLog(@"Changed %f %f", panDownLocation.x, panDownLocation.y);                        [self zoomInToRect:NSOffsetRect(self.bounds,                        -[sender locationInView:self].x+panDownLocation.x,                        -[sender locationInView:self].y+panDownLocation.y                  )            ];                        panDownLocation = [sender locationInView:self];            break;        default:            NSLog(@"Default %f %f", panDownLocation.x, panDownLocation.y);            break;    }}*/@end